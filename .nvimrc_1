let g:has_goyo     = match(&rtp, 'goyo') > -1
let g:has_deoplete = match(&rtp, 'deoplete ') > -1

"---------- https://raw.githubusercontent.com/guoqiao/vimrc/master/vimrc ------------ set nocompatible
syntax on
" for vim 7
set t_Co=256
" CG: commented out next block
" if has('termguicolors')
"     set termguicolors
" endif
syntax enable
filetype indent on

" use stuff from vim.wikia.com example vimrc
" bottom status bar
set showmode
set showcmd
set ruler
set laststatus=2
set scrolloff=5 " Minimal number of screen lines to keep above and below the cursor. (default=10)

set modeline    " Enables modeline
set modelines=5 " VIM shall consider modelines only if a modeline is contained within 5 lines of the top or bottom of file

set viminfo='100,n$HOME/.config/nvim/files/info/viminfo

"More natural split opening (see
"https://thoughtbot.com/blog/vim-splits-move-faster-and-more-naturally)
" Open new split panes to right and bottom, which feels more natural than Vim’s default:
set splitbelow
set splitright

" left side bar
set number
set relativenumber
" vi doesn't support this
set signcolumn=auto

" middle working area
set lazyredraw
set undolevels=1000
set backspace=eol,start,indent
set iskeyword+=-
" list mode, show tabs and spaces
set list
set listchars=tab:>-,trail:~,extends:>,precedes:<
" this will force cursor jump to new line
" set textwidth=80
set nowrap
set linebreak

set background=dark  " CG: Note LightBackgroundToggle() to toggle via <S-F1>

try
    " :colorscheme <Tab> --> list all
    " /usr/share/vim/vim80/colors
    " colorscheme desert
    " colorscheme darkblue
    " colorscheme industry
    " colorscheme dracula
    " colorscheme mustang
    " colorscheme apprentice
    " colorscheme spacegray
    " colorscheme tender
    " colorscheme hybrid_material
    " colorscheme hybrid_reverse
    " colorscheme jellybeans
    colorscheme gruvbox

" 'ayu-theme/ayu-vim' config
" let ayucolor="light"  " for light version of theme
" let ayucolor="mirage" " for mirage version of theme
let ayucolor="dark"   " for dark version of theme

" colorscheme ayu
catch /.*/
    colorscheme industry
endtry

" file
set hidden
set autoread
set wildignore=*.o,*~,*.pyc
set encoding=utf8
set ffs=unix,dos,mac
" Turn backup off, since most stuff is in git.
" set nobackup
set nowritebackup
set noswapfile
" make it possible to undo when reopen
" i.e. UNDO files are enabled, which means that UNDO will be session persistent
set undofile

set completeopt=menuone,longest " also autocomplete when there is only 1 choice, only insert the longest common text of the matches


" Font configuration
" These are the basic settings to get the font to work (required):
" set guifont=Droid\ Sans\ Mono\ for\ Powerline\ Nerd\ Font\ Complete\ 12

" // indicates that the file has abs path(?)
" set undodir=~/.vim/.undo//

"################################################################################
"save temporary files to /tmp/
"if tmp doesn't exist, make it
" http://stackoverflow.com/a/15317146/2958070
" https://www.reddit.com/r/vim/comments/2jpcbo/mkdir_issue/
" // indicates that the file has abs path(?)
silent! call mkdir($HOME . '/.config/nvim/backup', 'p')
set backupdir=~/.config/nvim/backup//
silent! call mkdir($HOME . '/.config/nvim/swap', 'p')
set directory=~/.config/nvim/swap//
if exists('&undodir') " Vim 7.2 doesn't have this
    silent! call mkdir($HOME . '/.config/nvim/undo', 'p')
    set undodir=~/.config/nvim/undo//
endif
"################################################################################

" :ls :buffers
" :bn(ext) :bp(rev)
" b <Tab>
" b xx<Tab>
"CG set wildmenu
"CG set wildmode=longest:list,full
"CG set wildchar=<Tab> wildcharm=<C-Z>

" No annoying sound on errors
set noerrorbells
set visualbell
set t_vb=
set tm=500

" search
" with ingorecase if all lowercase, otherwise case sensitive
set ignorecase
set smartcase
set hlsearch
set incsearch
set showmatch

" add all files to find path
" :find  FILE -> find FILE and open in current window
" :sfind FILE -> find FILE and open in split
" :tabf  FILE -> find FILE and open in tab
set path=$PWD/**

" enable wildmenu above status bar
set wildmenu  " Use tab to complete stuff in vim menu, Display all matches when tab complete.
" press Tab once: show list for all match as prompt
" press Tab twice: show wildmenu for all match and use Tab again to nav
set wildmode=list:longest,full

" set foldenable
" set foldmethod=indent
" set foldlevelstart=6
" set foldlevel=99
" set foldnestmax=10

" default indent 4-space
set autoindent
set copyindent  " copy the previous indentation on autoindenting
set smartindent
set cindent



" ################################################################################
" # Indent settings

" https://stackoverflow.com/a/1878984/2958070
set tabstop=4       " The width of a TAB is set to 4. Still it is a \t. It is just that
                    " Vim will interpret it to be having a width of 4.
set softtabstop=4   " Sets the number of columns for a TAB
set shiftwidth=4    " Indents will have a width of 4
set shiftround      " use multiple of shiftwidth when indenting with '<' and '>'
set expandtab       " Expand TABs to spaces
set smarttab        " When on, a <Tab> in front of a line inserts blanks according to 'shiftwidth'.
                    " 'tabstop' or 'softtabstop' is used in other places.

" Custom indent settings per filetype
augroup custom_filetype
    autocmd!
    autocmd BufNewFile,BufRead *.go setlocal noexpandtab shiftwidth=4 softtabstop=4 tabstop=4

    " Only use tabs in gitconfig
    " https://stackoverflow.com/questions/3682582/how-to-use-only-tab-not-space-in-vim
    autocmd BufRead,BufNewFile .gitconfig setlocal autoindent noexpandtab tabstop=8 shiftwidth=8
    autocmd BufRead,BufNewFile Vagrantfile set filetype=ruby

    " Don't highlight whitespace in xmlm html documents (as it would be done too often, see https://nvie.com/posts/how-i-boosted-my-vim/ )
    autocmd filetype html,xml set listchars-=tab:>.

    " https://superuser.com/a/907889/643441
    autocmd filetype crontab setlocal nobackup nowritebackup

    " Use 2 spaces to indent in these
    " autocmd FileType html,javascript,json,ruby,typescript,yaml setlocal shiftwidth=2 softtabstop=2
    autocmd FileType javascript,json,ruby,typescript setlocal shiftwidth=2 softtabstop=2
    autocmd FileType html,yaml   setlocal shiftwidth=2 softtabstop=2 tabstop=2 expandtab

    " c indent 8-space
    autocmd FileType c      setlocal shiftwidth=8 softtabstop=8 tabstop=8 noexpandtab

    " " frontend indent 2-space
    " autocmd FileType html,yaml   setlocal shiftwidth=2 softtabstop=2 tabstop=2 expandtab
    " " c indent 8-space
    " autocmd FileType c      setlocal shiftwidth=8 softtabstop=8 tabstop=8 noexpandtab
augroup END


" TODO: clean up indent settings ( https://stackoverflow.com/a/1878983/2958070 )
function! IndentSpacesToggle()
    if &softtabstop == 2
        setlocal tabstop=4
        setlocal shiftwidth=4
        setlocal softtabstop=4
        setlocal expandtab
        echom "#spaces per indent = 4"
    else
        setlocal tabstop=2
        setlocal shiftwidth=2
        setlocal softtabstop=2
        setlocal expandtab
        echom "#spaces per indent = 2"
    endif
endfunction

command! IndentSpacesToggle call IndentSpacesToggle()

" Sometimes I dont want to indent (yaml files in particular)
command! StopIndenting setl noai nocin nosi inde=

" Set Visual Studio style indents
command! VSIndentStyle set noexpandtab shiftwidth=4 softtabstop=4 tabstop=4
" ###############################################################################

set history=9999
set tags=tags

nnoremap ; :

" nnoremap 0 ^
" nnoremap <Space> $

" nnoremap B ^
" nnoremap E $

" Yank from the cursor to the end of the line, to be consistent with C and D.
nnoremap Y y$

" Treat long lines as break lines (useful when moving around in them)
nnoremap j gj
nnoremap k gk

"################################################################################
" Smart way to move between windows
" This is now on plug in https://github.com/christoomey/vim-tmux-navigator
" which makes it also work in tmux split settings
nnoremap <C-n> <ESC><C-w><C-w>
nnoremap <C-j> <ESC><C-w><C-j>
nnoremap <C-k> <ESC><C-w><C-k>
nnoremap <C-l> <ESC><C-w><C-l>
nnoremap <C-h> <ESC><C-w><C-h>

nnoremap <silent> <C-LEFT> :vertical resize +5<CR>
nnoremap <silent> <C-RIGHT> :vertical resize -5<CR>
nnoremap <silent> <C-UP> :resize +5<CR>
nnoremap <silent> <C-DOWN> :resize -5<CR>


" nnoremap <LEFT> :echom 'LEFT KEY_DISABLED_BY_CG'<CR><C-W><
" nnoremap <RIGHT> :echom 'RIGHT KEY_DISABLED_BY_CG'<CR><C-W>>
nnoremap <LEFT> :echom 'LEFT KEY_DISABLED_BY_CG'<CR>
nnoremap <RIGHT> :echom 'RIGHT KEY_DISABLED_BY_CG'<CR>
nnoremap <DOWN> :echom 'DOWN KEY_DISABLED_BY_CG'<CR>
nnoremap <UP> :echom 'UP KEY_DISABLED_BY_CG'<CR>
" Smart way to manage tabs
nnoremap tl :tabnext<CR>
nnoremap th :tabprev<CR>
nnoremap tn :tabnew<CR>
nnoremap tc :tabclose<CR>
nnoremap tm :tabmove<CR>
nnoremap to :tabonly<CR>



" let mapleader = "\<Space>"
" let mapleader = " "
let mapleader = ","


nnoremap <leader>0 :Tabularize /=<CR>
vnoremap <leader>0 :Tabularize /=<CR>
nnoremap <leader>= :Tabularize /=<CR>
vnoremap <leader>= :Tabularize /=<CR>

nnoremap <leader>- :Tabularize /-<CR>
vnoremap <leader>- :Tabularize /-<CR>

nnoremap <leader>. :Tabularize /:<CR>
vnoremap <leader>. :Tabularize /:<CR>
nnoremap <leader>: :Tabularize /:<CR>
vnoremap <leader>: :Tabularize /:<CR>

nnoremap <leader>+ :Tabularize /\<CR>
vnoremap <leader>+ :Tabularize /\<CR>
nnoremap <leader>\ :Tabularize /\<CR>
vnoremap <leader>\ :Tabularize /\<CR>

let loaded_matchparen = 1 " disable math parenthiese

"################################################################################
if !has("gui_running")
    set confirm "open a save dialog when quitting
endif

if exists('&inccommand')
    set inccommand=split
endif


" map j to gj and k to gk, so line navigation ignores line wrap
nnoremap j gj
nnoremap k gk

nnoremap <leader>V ggVG
nnoremap <C-A> ggVG

" Tab through buffers (writes to them...)
nnoremap  <silent>   <tab>  :if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR>:bnext<CR>
nnoremap  <silent> <s-tab>  :if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR>:bprevious<CR>



" TERMINAL MODE mappings {
" To map <Esc> to exit terminal-mode: >
tnoremap <Esc> <C-\><C-n>

" To simulate |i_CTRL-R| in terminal-mode: >
tnoremap <expr> <C-R> '<C-\><C-N>"'.nr2char(getchar()).'pi'

" To use `ALT+{h,j,k,l}` to navigate windows from any mode: >
tnoremap <A-h> <C-\><C-N><C-w>h
tnoremap <A-j> <C-\><C-N><C-w>j
tnoremap <A-k> <C-\><C-N><C-w>k
tnoremap <A-l> <C-\><C-N><C-w>l
inoremap <A-h> <C-\><C-N><C-w>h
inoremap <A-j> <C-\><C-N><C-w>j
inoremap <A-k> <C-\><C-N><C-w>k
inoremap <A-l> <C-\><C-N><C-w>l
nnoremap <A-h> <C-w>h
nnoremap <A-j> <C-w>j
nnoremap <A-k> <C-w>k
nnoremap <A-l> <C-w>l
" TERMINAL MODE mappings }



" Use bash highlighting instead of sh highlighting
" let g:is_posix = 1
let g:is_bash = 1

" Make some stuff uncopyable on HTML output
" :help :TOhtml
let g:html_prevent_copy = "fn"


" To use the clipboard on linux, install xsel
if has('clipboard')
    "Use system CLIPBOARD by as default yank register
    " ==> vapy  will copy a paragraph info CLIPBOARD
    " (otherwise I would need to : vap"+y to address CLIPBOARD register explicitly ("+)
    set clipboard^=unnamedplus,unnamed
endif

" Map jk to <Esc> to preent having to leave the home row
inoremap jk <ESC>

" save without sudo vim
cmap w!! w !sudo tee > /dev/null %

if has("nvim")
    tnoremap <Esc> <C-\><C-n>
    tnoremap fd  <C-\><C-n>
    " split settings
    " This doesn't work with my tmux plugin
    " go to next bufer
    tnoremap <C-n> <C-\><C-n><C-w><C-w>
    " Map Ctrl+ <motion> to <Terminal escape> + < Window Control> + <Motion>
    tnoremap <C-j> <C-\><C-n><C-w><C-j>
    tnoremap <C-k> <C-\><C-n><C-w><C-k>
    tnoremap <C-l> <C-\><C-n><C-w><C-l>
    tnoremap <C-h> <C-\><C-n><C-w><C-h>
    " open terminal in vertical split instead of new buffer
    command! Term :vert sp | term
    " Hopefully, this keeps buffers when I switch windows
    autocmd TermOpen * set bufhidden=hide
endif

" disable error bells
if !has("nvim")
    set nocompatible
    set visualbell t_vb=
endif

augroup aug_diffs
    au!
    " au WinEnter,BufEnter * call timer_start(50, 'CheckDiffMode')
    "Highlight VCS conflict markers
    au VimEnter,WinEnter * if !exists('w:_vsc_conflict_marker_match') |
        \ let w:_vsc_conflict_marker_match = matchadd('ErrorMsg', '^\(<\|=\||\|>\)\{7\}\([^=].\+\)\?$') |
        \ endif
augroup END


" function CheckDiffMode(timer)
"     let curwin = winnr()
"     "Check each window
"     for _win in range(1, winnr('$'))
"         exe "noautocmd " . _win . "wincmd w"
"
"         call s:change_option_in_diffmode('b:', 'syntax', 'off')
"         call s:change_option_in_diffmode('w:', 'spell', 0, 1)
"     endfor
"
"     "Get back to original window
"     exe "noautocmd " . curwin . "wincmd w"
" endfunction
"
"
" function s:change_option_in_diffmode(scope, option, value, ...)
"     let isBoolean = get(a:, "1", 0)
"     let backupVarname = a:scope . "_old_" . a:option
"
"     "Entering diff Mode
"     if &diff && !exists(backupVarname)
"         exe "let " . backupVarname . "=&" . a:option
"         call s:set_option(a:option, a:value, 1, isBoolean)
"     endif
"
"     "Exiting diff mode
"     if !&diff && exists(backupVarname)
"         let oldValue = eval(backupVarname)
"         call s:set_option(a:option, a:value, 1, isBoolean)
"         exe "unlet " . backupVarname
"     endif
" endfunction



" http://stackoverflow.com/a/18444962/2958070
" custom file templates
augroup templates
    au!
    autocmd BufNewFile *.* silent! execute '0r ~/.config/nvim/templates/skeleton.'.expand("<afile>:e")
augroup END

function! ShowFuncName()
    let lnum = line(".")
    let col = col(".")
    echohl ModeMsg
    echo getline(search("^[^ \t#/]\\{2}.*[^:]\s*$", 'bW'))
    echohl None
    call search("\\%" . lnum . "l" . "\\%" . col . "c")
endfunction
command! ShowFuncName call ShowFuncName()

command! -nargs=1 Help vert help <args>

function Open(open_me)
    let open_me = expand(a:open_me)
    if has('win32')
        execute "silent !start " . a:open_me
    elseif has('mac')
        execute "silent !open " . a:open_me
    else
        execute "silent !xdg-open " . a:open_me
    endif
endfunction
command! Open call Open('%')
command! OpenDir call Open('%:p:h')


"################################################################################

"see http://vimcasts.org/episodes/the-edit-command/
" expand('%:h') -->  <dirname(CURRENT_FILE)>
" expand('%:p') -->  <CURRENT_FILE>
"e.g:  /tmp/.nvimrc_1  --> /tmp
"
" In command mode:  '%%'  -expands_to->  <dirname(CURRENT_FILE)>
cnoremap %% <C-R>=expand('%:h').'/'<cr>
" In command mode:   -expands-to->   <CURRENT_FILE>  (provided by fugitive
" plugin)


map <leader>ee :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%

noremap <leader>h :noh<CR>
noremap <leader>w :w<CR>
" noremap <leader>e :e!<CR>   " mapping already used by default by scalpel PLUGIN
noremap <leader>x :x<CR>
noremap <leader>zz :wqa<CR> " write and quit all buffers

" noremap <leader>q :q<CR>
" nnoremap Q <nop>  " Dont enter EX-mode by presssing 'Q' (default vim behavior)
nnoremap Q :call QuickfixToggle()<cr>

let g:quickfix_is_open = 0
function! QuickfixToggle()
    if g:quickfix_is_open
        cclose
        let g:quickfix_is_open = 0
        " go back to the window/split where we came from
        " before entering the QUICKFIX window
        execute g:quickfix_return_to_window . "wincmd w"
    else
        let g:quickfix_return_to_window = winnr()
        copen
        let g:quickfix_is_open = 1
    endif
endfunction



map <S-F1> :call LightBackgroundToggle()<CR>

function! LightBackgroundToggle()
    if &background ==# 'dark'
        set background=light
    else
        set background=dark
    endif
endfunction
command! LightBackgroundToggle call LightBackgroundToggle()




" ##########  goyo and limelight {
" let g:goyo_width  = 90   " (default: 80)
" let g:goyo_height = '90%' " (default: 85%)
" let g:goyo_linenr = 0     " (default: 0)

let g:limelight_conceal_ctermfg = 'gray'
let g:limelight_conceal_ctermfg = 240

function! s:goyo_enter()
  if executable('tmux') && strlen($TMUX)
    silent !tmux set status off
    silent !tmux list-panes -F '\#F' | grep -q Z || tmux resize-pane -Z
  endif
  set noshowmode
  set noshowcmd
  set nocursorline
  set scrolloff=999
  Limelight
  " ...
endfunction

function! s:goyo_leave()
  if executable('tmux') && strlen($TMUX)
    silent !tmux set status on
    silent !tmux list-panes -F '\#F' | grep -q Z && tmux resize-pane -Z
  endif
  set cursorline
  set showmode
  set showcmd
  set scrolloff=5
  Limelight!
  " ...
endfunction


let g:goyo_is_open = 0
function! s:goyo_toggle()
    if g:goyo_is_open
        Goyo!
		" call <SID>goyo_leave()
        let g:goyo_is_open = 0
    else
		" call <SID>goyo_enter()
        Goyo 90x90%
        let g:goyo_is_open = 1
    endif
endfunction


autocmd! User GoyoEnter nested call <SID>goyo_enter()
autocmd! User GoyoLeave nested call <SID>goyo_leave()

command! GoyoToggle :call <SID>goyo_toggle()

" ##########  goyo and limelight }



nnoremap <leader>b  :e $HOME/dotfiles/.bashrc<CR>
nnoremap <leader>bb :ls<CR>:buffer<Space>
nnoremap <leader>v  :e $HOME/dotfiles/.nvimrc_1<CR>
nnoremap <leader>t  :e /home/cg/dotfiles/.tmux.conf<CR>
noremap  <leader>p  :e $HOME/dotfiles/vim_plugins.vim<CR>
noremap  <leader>sv :source $HOME/.nvimrc_1<CR>
noremap  <leader>sp :source $HOME/dotfiles/vim_plugins.vim<CR>
noremap  <leader>sc :source %<CR>

noremap  <leader>vv :e $MYVIMRC<CR>

if filereadable(expand("~/workspace/nvim__last_session.vim"))
    nnoremap <leader>ss :mksession! $HOME/workspace/nvim__last_session.vim
else
    nnoremap <leader>ss :mksession! $HOME/.config/nvim/last_session.vim
endif

" reload vimrc
" command! ReloadVimrc source $MYVIMRC
" command! EditVimrc :edit $MYVIMRC
command! ReloadVimrc source $MYVIMRC
command! EditVimrc :edit $MYVIMRC
" command!  -range=% -nargs=0 -bar ExpandTabs :retab<CR>
command! ExpandTabs :retab<CR>


set pastetoggle=<F2>

set t_Co=256
set guioptions-=r  "remove right hand scrollbar
set guioptions-=L  "remove left hand scrollbar

" add transparency, must be after colorscheme
function! InstallVimPlug()
    if empty(glob("~/.config/nvim/autoload/plug.vim"))
        if executable('curl')
            let plugpath = "https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"
            silent exec "!curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs " . plugpath
            redraw!
            echom "Now restart the editor"
        else
            echom "Install curl"
        endif
    else
        echom "vim-plug installed!"
    endif
endfunction
command! InstallVimPlug call InstallVimPlug()

if executable("rg")
    set grepprg=rg\ --vimgrep
endif

if executable('cloc')
    command! VimConfigStats exec '!cloc --by-file-by-lang --exclude-dir=syntax,bundle,autoload,templates ~/.config/nvim'
    command! Cloc !cloc %
endif

" TODO: checkout :h formatexpr and :h formatprg

if executable('python')
    command! JSONFormat %!python -m json.tool
endif

" Format current Python file
if executable('black')
    " https://github.com/psf/black/issues/431
    command! BlackFormat %!black -q - < %
endif

if executable('gofmt')
    command! GoFormat %!gofmt %
endif

if executable('terraform')
    command! TerraFormat %!terraform fmt -no-color - < %
endif

" use zg to add word to word-list
" ]s and [s jump to misspelled words
function! SpellCheckToggle()
    if &spell
        setlocal nospell
        setlocal complete-=kspell
    else
        setlocal spell spelllang=en_us
        " turn on auto-completion with C-n, C-p
        setlocal complete+=kspell
    endif
endfunction
command! SpellCheckToggle call SpellCheckToggle()
" format existing text by selecting it and using `gq`

command! SearchHLToggle :setlocal invhlsearch

function! NumberToggle()
    if &number
        setlocal nonumber
    else
        setlocal number
    endif
endfunction
command! NumberToggle call NumberToggle()

" TODO: optional filename to save to
function! WriteHTML()
    silent exec "TOhtml"
    silent exec "w"
    silent exec "q"
endfunction

" http://superuser.com/a/277326/643441
command! TouchFile :call writefile([], expand("<cfile>"), "t")

function! UpByIndent()
    norm! ^
    let start_col = col(".")
    let col = start_col
    while col >= start_col
        norm! k^
        if getline(".") =~# '^\s*$'
            let col = start_col
        elseif col(".") <= 1
            return
        else
            let col = col(".")
        endif
    endwhile
endfunction
command! UpByIndent :call UpByIndent()

" http://stackoverflow.com/a/749320/2958070
" exit with :q or :diffoff
function! s:DiffWithSaved()
    let filetype=&ft
    diffthis
    vnew | r # | normal! 1Gdd
    diffthis
    exe "setlocal bt=nofile bh=wipe nobl noswf ro ft=" . filetype
endfunction
command! DiffSaved call s:DiffWithSaved()

command! FullPath echo expand('%:p')

function! SetExecutableBit()
    let fname = expand("%:p")
    checktime
    execute "au FileChangedShell " . fname . " :echo"
    silent !chmod a+x %
    checktime
    execute "au! FileChangedShell " . fname
endfunction
command! SetExecutableBit call SetExecutableBit()

" The 'e' on the end of the substitute ignores errors
" -range=% means without a visual selection the whole buffer is selected
"  Special thanks to a @jfim for the link substitution line
"  Note that top level lists can be represented by ^-, not ^*
"  TODO: handle ^# substitution in code blocks
command! -range=% -nargs=0 -bar MarkdownToJira
    \ :<line1>,<line2>s:^  - :** :e
    \ | <line1>,<line2>s:^    - :*** :e
    \ | <line1>,<line2>s:^```:{noformat}:e
    \ | <line1>,<line2>s:^# :h1. :e
    \ | <line1>,<line2>s:^## :h2. :e
    \ | <line1>,<line2>s:^### :h3. :e
    \ | <line1>,<line2>s: `: {{:eg
    \ | <line1>,<line2>s:^`:{{:e
    \ | <line1>,<line2>s:` :}} :eg
    \ | <line1>,<line2>s:`$:}}:eg
    \ | <line1>,<line2>s:`\.:}}.:eg
    \ | <line1>,<line2>s:^\d\+\. :# :e
    \ | <line1>,<line2>s/\v\[([^\]]*)\]\(([^\)]*)\)/[\1|\2]/ge

" TODO: add filtype on top?
" NOTE: add bottom one first to not mess up what's <line2>
command! -range=% -nargs=0 -bar AddCodeFence
    \ :<line2>s:$:\r```:
    \ | <line1>s:^:```\r:

" https://unix.stackexchange.com/a/58748/185953
" <line1>,<line2>VisualSelect
command! -range VisualSelect normal! <line1>GV<line2>G

" One thing I can do is hit Ctrl + x, Ctrl + e to open up my $EDITOR (NeoVim)
" to edit the long command (Bash 1-liner)
" . Now I can use all of Vim’s tricks to edit my command.
" But I’m still faced with the problem of it being all in one line,
"  hard to read and not super nice to edit.
"
" Now, when calling the FormatShellCmd function after having maunched vim by pressing  inside BASH
" The formerly long 1-liner will be split and nicely presented in multiples lines inside the vim buffer and can be edited easily
" and when the vim instance is closed the edited long command will be executed within the BASH instance that formerly spawnwd VIM (after pressing )
" See https://www.bbkane.com/2020/04/14/Long-Shell-Oneliners-Without-the-Pain.html
command! -range FormatShellCmd <line1>!format_shell_cmd.py

" Mostly for ordered lists in Markdown
" https://stackoverflow.com/a/4224454/2958070
command! -nargs=0 -range=% NumberLines <line1>,<line2>s/^\s*\zs/\=(line('.') - <line1>+1).'. '
command! -nargs=0 -range=% UnNumberLines <line1>,<line2>s/\d\+\. //g

" https://askubuntu.com/a/686806/483521
command! InsertDate :execute 'norm i' .
    \ substitute(system("date '+%a %b %d - %Y-%m-%d %H:%M:%S %Z'"), '\n\+$', '', '')

" Finally, load secretive stuff not under version control
if !empty(glob("~/.config/nvim_local.vim"))
    source ~/.config/nvim_local.vim
    command! EditNvimLocal :edit ~/.config/nvim_local.vim
endif

"################################################################################
"################################################################################
"################################################################################
"################################################################################

highlight Normal guibg=NONE ctermbg=NONE
highlight ColorColumn ctermbg=LightCyan
" set colorcolumn=80
set colorcolumn=      " type:string, defaults to ''  ==> disabled by default (can be enabled by F7 toggler)  ==> disabled by default (can be enabled by F7 toggler
"let &colorcolumn="80,".join(range(120,999),",")

" " cursor shape and color
" highlight Cursor guifg=white guibg=black
" highlight iCursor guifg=white guibg=steelblue
" set guicursor=n-v-c:block-Cursor
" set guicursor+=i:ver100-iCursor
" set guicursor+=n-v-c:blinkon10
" set guicursor+=i:blinkwait10
"
"

highlight Cursor guifg=white guibg=black ctermfg=red ctermbg=green
highlight iCursor guifg=red guibg=steelblue ctermfg=red ctermbg=NONE
set guicursor=n-v-c:block-Cursor
set guicursor+=i:ver100-iCursor
set guicursor+=n-v-c:blinkon1
"set guicursor+=i:blinkwait10


" Uncomment the following line if cursorline should always be highlighted
" set cursorline  " underlines current line
" set nocursorline  " underlines current line

" Only show cursorline in insert mode
" with yellow underline
" hi CursorLine gui=underline cterm=underline ctermfg=yellow guifg=yellow
" hi CursorLine gui=underline cterm=underline ctermfg=None guifg=None ctermbg=None
" hi CursorLine gui=underline cterm=underline ctermfg=None guifg=None
" hi CursorLine gui=None cterm=None ctermfg=black ctermbg=grey
" hi CursorLine gui=None cterm=None ctermfg=black ctermbg=lightgrey
" hi CursorLine cterm=reverse gui=reverse
hi CursorLine gui=None cterm=None ctermfg=black ctermbg=darkgrey   " CG: used e.g. for 'textDocument_hover' (<A-F1>)

" autocmd InsertEnter * set cursorline
" autocmd InsertLeave * set nocursorline

autocmd! bufwritepost vimrc source %
command! FJ % !python3 -m json.tool


function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction

function! VisualSelection(direction, extra_filter) range
    let l:saved_reg = @"
    execute "normal! vgvy"

    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")

    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.' . a:extra_filter)
    elseif a:direction == 'replace'
        call CmdLine("%s" . '/'. l:pattern . '/')
    elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
    endif

    let @/ = l:pattern
    let @" = l:saved_reg
endfunction

" Visual mode pressing * or # searches for the current selection
" Super useful! From an idea by Michael Naumann
vnoremap <silent> * :call VisualSelection('f', '')<CR>
vnoremap <silent> # :call VisualSelection('b', '')<CR>
" When you press <leader>r you can search and replace the selected text
vnoremap <silent> <leader>r :call VisualSelection('replace', '')<CR>


" goog vim reference
" https://www.tutorialdocs.com/article/vim-configuration.html

" load plugins if available
if filereadable(expand("~/.vim/pack/devpy/vimrc.pack"))
  source ~/.vim/pack/devpy/vimrc.pack
endif




"----------------- CG -------------------

""""""" See http://www.ibm.com/developerworks/linux/library/l-vim-script-1/index.html
"Listing 1. Toggling syntax highlighting
function! ToggleSyntax()
   if exists("g:syntax_on")
      syntax off
   else
      syntax enable
   endif
endfunction

nmap <silent>  <SPACE>s  :call ToggleSyntax()<CR>

" u is undo ==> U is redo
nmap U :redo<CR>


function! CapitalizeCenterAndMoveDown()
   s/\<./\u&/g   "Built-in substitution capitalizes each word
   center        "Built-in center command centers entire line
   +1            "Built-in relative motion (+1 line down)
endfunction

nmap <silent>  <SPACE>c  :call CapitalizeCenterAndMoveDown()<CR>

"Highlighting frequently misused words (see )

"Create a text highlighting style that always stands out...
highlight STANDOUT term=bold cterm=bold gui=bold ctermfg=yellow ctermbg=blue

"List of troublesome words...
let s:words = [
             \ "it's",  "its",
             \ "your",  "you're",
             \ "were",  "we're",   "where",
             \ "their", "they're", "there",
             \ "to",    "too",     "two"
             \ ]

"Build a Vim command to match troublesome words...
let s:words_matcher
\ = 'match STANDOUT /\c\<\(' . join(s:words, '\|') . '\)\>/'

"Toggle word checking on or off...
" Word checking is enabled by setting Vim's match command. A match expects a
" text-highlighting specification (STANDOUT in this example), followed by a
" regular expression that specifies which text to highlight. In this case,
" that regex is constructed by OR'ing together all of the words specified in
" the script's s:words list variable (that is: join(s:words, '\|')). That set
" of alternatives is then bracketed by case-insensitive word boundaries
" (\c\<\(...\)\>) to ensure that only entire words are matched, regardless of
" capitalization."
function! WordCheck ()
   "Toggle the flag (or set it if it doesn't yet exist)...
   let w:check_words = exists('w:check_words') ? !w:check_words : 1

   "Turn match mechanism on/off, according to new state of flag...
   if w:check_words
      exec s:words_matcher
   else
      match none
   endif
endfunction

"Use ;p to toggle checking...

nmap <silent>  <SPACE>wc  :call WordCheck()<CR>


""""""" See http://www.ibm.com/developerworks/linux/library/l-vim-script-1/index.html
"Scripting in Insert mode
"Vimscripting is by no means restricted to Normal mode. You can also use the imap or iabbrev commands to set up key-mappings or abbreviations that can be used while inserting text. For example:
"imap <silent> <C-D><C-U> [due: <C-R>=strftime("%d.%m.%y")]<CR>
imap <silent> <C-D><C-U> [due:  <C-R>=strftime("%d.%m.%Y") <CR>]<SPACE><SPACE>
imap <silent> <C-D><C-D> <C-R>=strftime("%02e %b. %Y")<CR>
imap <silent> <C-T><C-T> <C-R>=strftime("%02l:%M %p")<CR>
imap <silent> <C-D><C-T> <C-R>=strftime("%02e %b. %Y") . strftime("%02l:%M %p")<CR>
"With these mappings in your .vimrc, typing CTRL-D twice while in Insert mode causes Vim to call its built-in strftime() function and insert the resulting date, while double-tapping CTRL-T likewise inserts the current time.
"You can use the same general pattern to cause an insertion map or an abbreviation to perform any scriptable action. Just put the appropriate Vimscript expression or function call between an initial <C-R>= (which tells Vim to insert the result of evaluating what follows) and a final <CR> (which tells Vim to actually evaluate the preceding expression). Remember, though, that <C-R> (Vim's abbreviation for CTRL-R) is not the same as <CR> (Vim's abbreviation for a carriage return).
"For example, you could use Vim's built-in getcwd() function to create an abbreviation for the current working directory, like so:
iabbrev <silent> CWD <C-R>=getcwd()<CR>
"Or you could embed a simple calculator that can be called by typing CTRL-C during text insertions:
imap <silent> <C-C> <C-R>=string(eval(input('Calculate: ')))<CR>
"Here, the expression:
"string( eval( input("Calculate: ") ) )
"first calls the built-in input() function to request the user to type in their calculation, which input() then returns as a string. That input string is then passed to the built-in eval(), which evaluates it as a Vimscript expression and returns the result. Next, the built-in string() function converts the numeric result back to a string, which the key-mapping's <C-R>= sequence is then able to insert.


" In INSERT mode:
" when line is ending in word 'cg', the 'cg' will be subsituted with 'Chrisian Günther'
" when line is ending in word 'auth', the 'auth' will be subsituted with 'Author: Chrisian Günther'
"
iabbrev <silent> cg<C-R> Christian Günther<CR>
iabbrev <silent> auth<C-R> Author: Christian Günther<CR>



""""""" See http://www.ibm.com/developerworks/linux/library/l-vim-script-1/index.html

"Listing 11. Improving vertical copies to ignore blank lines
"  The LookUpwards() function first determines which on-screen column (or "virtual column") the insertion point is currently in, using the built-in virtcol() function. The '.' argument specifies that you want the column number of the current cursor position:
"  let column_num = virtcol('.')
"  LookUpwards() then uses the built-in search() function to look backwards through the file from the cursor position:
"  let target_pattern = '\%' . column_num . 'v.'
"  let target_line_num = search(target_pattern . '*\S', 'bnW')
"  The search uses a special target pattern (namely: \%column_numv.*\S) to locate the closest preceding line that has a non-whitespace character (\S) at or after (.*) the cursor column (\%column_numv). The second argument to search() is the configuration string bnW, which tells the function to search backwards but not to move the cursor nor to wrap the search. If the search is successful, search() returns the line number of the appropriate preceding line; if the search fails, it returns zero.
"  The if statement then works out which character—if any—is to be copied back down to the insertion point. If a suitable preceding line was not found, target_line_num will have been assigned zero, so the first return statement is executed and returns an empty string (indicating "insert nothing").
"  If, however, a suitable preceding line was identified, the second return statement is executed instead. It first gets a copy of that preceding line from the current editor buffer:
"  return matchstr(getline(target_line_num), target_pattern)
"  It then finds and returns the one-character string that the previous call to search() successfully matched:
"  return matchstr(getline(target_line_num), target_pattern)
"  Having implemented this new vertical copy behavior inside LookUpwards(), all that remains is to override the standard CTRL-Y command in Insert mode, using an imap:
"  imap <silent> <C-Y> <C-R><C-R>=LookUpwards()<CR>
"  Note that, whereas earlier imap examples all used <C-R>= to invoke a Vimscript function call, this example uses <C-R><C-R>= instead. The single-CTRL-R form inserts the result of the subsequent expression as if it had been directly typed, which means that any special characters within the result retain their special meanings and behavior. The double-CTRL-R form, on the other hand, inserts the result as verbatim text without any further processing.
"  Verbatim insertion is more appropriate in this example, since the aim is to exactly copy the text above the cursor. If the key-mapping used <C-R>=, copying a literal escape character from the previous line would be equivalent to typing it, and would cause the editor to instantly drop out of Insert mode.

"Locate and return character "above" current cursor position...
function! LookUpwards()
   "Locate current column and preceding line from which to copy...
   let column_num      = virtcol('.')
   let target_pattern  = '\%' . column_num . 'v.'
   let target_line_num = search(target_pattern . '*\S', 'bnW')

   "If target line found, return vertically copied character...

   if !target_line_num
      return ""
   else
      return matchstr(getline(target_line_num), target_pattern)
   endif
endfunction


"Reimplement CTRL-Y within insert mode...
" imap <silent>  <C-Y>  <C-R><C-R>=LookUpwards()<CR>
" CG: <C-Y> is already mapped by EMMET plugin ==> Map <leader>y instead
imap <silent>  <leader>y  <C-R><C-R>=LookUpwards()<CR>


""""""" See http://vim.wikia.com/wiki/VimTip315
"The following lines (in your vimrc) implement smart home for normal, visual, operator pending, and insert modes.
"The first line is an expression mapping for normal, visual, and operator pending modes. The right-hand side of the mapping is an expression that is evaluated each time Home is pressed. The expression gives a string, and the result is as if the characters in the string had been pressed. The expression compares col('.') (the cursor column position, where 1 is the first column) and match(getline('.'),'\S')+1 (the index of the first non-whitespace character in the current line; 1 is added because the index starts at 0). If both sides of "==" are equal, the result is '0' (move to start of line); otherwise it is '^' (move to first nonblank character).
noremap <expr> <silent> <Home> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
imap <silent> <Home> <C-O><Home>


""""""" See http://vim.wikia.com/wiki/VimTip431
"Change to forward/back slashesEdit
"The following mappings (for your vimrc) allow easily changing slashes in the current line.
"By default the <Leader> key is backslash, and <Bslash> is a way to refer to a backslash in a mapping, so by default these commands map \/ and \\ respectively.

"Press <Leader>/ to change every backslash to a forward slash, in the current line.

"Press <Leader>\ to change every forward slash to a backslash, in the current line.

"The mappings save and restore the search register (@/) so a previous search can be continued, if wanted. The :noh command is used to remove search highlighting (if enabled) to avoid search hits being highlighted after setting the search register.
"In the substitute command (:s), a colon (:) is used as a delimiter, so the slashes do not need to be escaped. The substitute flags (ge) cause all occurrences on the line to be substituted (g), and no error to be reported if no slash is found (e).

" nnoremap <silent> <Leader>/ :let tmp=@/<Bar>s:\\:/:ge<Bar>let @/=tmp<Bar>noh<CR>
" nnoremap <silent> <Leader><Bslash> :let tmp=@/<Bar>s:/:\\:ge<Bar>let @/=tmp<Bar>noh<CR>
nnoremap <silent> sl :let tmp=@/<Bar>s:\\:/:ge<Bar>let @/=tmp<Bar>noh<CR>
nnoremap <silent> bs :let tmp=@/<Bar>s:/:\\:ge<Bar>let @/=tmp<Bar>noh<CR>



"CG's                                                  : 'Underline current line' mapping
"----------------------------------------------------------------------------------------
"1. copy current line                                  : yyp
"2. remove trailing whitespace in copied line          : :s/\s\+$//e<cr>
"4. Jumop to startof line (ignore preceding whitespace : ^
"5. select until end of line                           : v$
"6. replace with -                                     : r-
"----------------------------------------------------------
nnoremap <leader>ul <esc>yyp:s/\s\+$//e<cr>^v$r-
nnoremap <leader>ul <esc>yyp:s/\s\+$//e<cr>^v$r-
inoremap <leader>ul <esc>yyp:s/\s\+$//e<cr>^v$r-
"----------------------------------------------------------

"Tired of clearing highlighted searches by searching for “ldsfhjkhgakjks”? Use this:
nmap <silent> ,/ :nohlsearch<CR>


"search for visual selection
:vmap // y/<C-R>"<CR>


" -----   ruby interpolation via surround plugin -----
"  35 is ASCII code for '#' : determined with :echo char2nr('#')
"  37 is ASCII code for '%' : determined with :echo char2nr('%')
"  61 is ASCII code for '=' : determined with :echo char2nr('=')
let g:surround_35 = "#{\r.inspect}"
let g:surround_37 = "<% \r %>"
let g:surround_61 = "<%= \r %>"

" Expand {xyz} --> { xyz }   ( change open brace )
nnoremap cob :normal cs{{<cr>

nmap <leader>m viwygvS#vf}S'Pli=<esc>4lva'<esc>
vmap <leader>m    ygvS#vf}S'Pli=<esc>4lva'<esc>

" # turns  <cword>  ->  #{<cword>}
vmap <leader># viwS#
nmap <leader># viwS#


" Removes trailing spaces in current buffer
function! TrimWhiteSpace()
    %s/\s\+$//e
:endfunction


function! CompileGraphvizDotFileAndShow()
  let l:fname = expand('%:p')
  GraphvizCompile
  echo "Viewing " . l:fname
  GraphvizShow
endfunction


""""""""""""""""""""""" NERDTree config """""""""""""""""""""""""""""
let NERDTreeChDirMode=2
"let NERDTreeIgnore=['\env','\.vim$', '\~$', '\.pyc$', '\.swp$', '\.egg-info$', '^dist$', '^build$']
let NERDTreeIgnore=['^\.svn$','\~$', '\.rbc$', '\.swp$', '\.egg-info$', '^dist$', '^build$', '\.a$', '\.o$', '\.so']
let NERDTreeSortOrder=['\.rb$', '\/$', '*']
let NERDTreeShowBookmarks=1
let NERDTreeShowHidden=1
let NERDTreeHightlightCursorline=1
let NERDChristmasTree=1
"open NERDTEE by default"
"autocmd vimenter * NERDTree

"Q. How can I open a NERDTree automatically when vim starts up if no files were specified?
" au! vimenter * if !argc() | NERDTree | endif

"Q. How can I map a specific key or shortcut to open NERDTree?
"A. Stick this in your vimrc to open NERDTree with Ctrl+n (you can set whatever key you want): map <C-n> :NERDTreeToggle<CR>

"Q. How can I close vim if the only window left open is a NERDTree?
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

" autocmd BufWinEnter * NERDTreeFind
map ] :NERDTreeFind<CR> “ pressing this inside any open file in vim will jump to the nerdtree and highlight where that file is -> very useful when you have multiple files open at once


" See http://www.bashoneliners.com/?page=2
" Make a hexdump or do the reverse with the xxd command
" bash$ xxd /path/to/binary/file
" — by openiduser3 on May 16, 2012, 8:22 a.m.
"
" Explanation
" This shows a very nice hexdump of the specified file. You can edit the output and convert it back to binary with xxd -r. But the best part is that you can configure vim to do all the converting back and forth for you, effectively turning vim into a binary editor, by adding this to your .vimrc:
"

augroup Binary
        au!

        au BufReadPre  *.bin let &bin=1
        au BufReadPost *.bin if &bin | %!xxd
        au BufReadPost *.bin set ft=xxd | endif
        au BufWritePre *.bin if &bin | %!xxd -r
        au BufWritePre *.bin endif
        au BufWritePost *.bin if &bin | %!xxd
        au BufWritePost *.bin set nomod | endif

    au BufReadPre  *.hal let &bin=1
    au BufReadPost *.hal if &bin | %!xxd
    au BufReadPost *.hal set ft=xxd | endif
    au BufWritePre *.hal if &bin | %!xxd -r
    au BufWritePre *.hal endif
    au BufWritePost *.hal if &bin | %!xxd
    au BufWritePost *.hal set nomod | endif
augroup END



"   if wanted, you can temporarily turn off Vim's paging so there will be no "More" prompts, as shown in the following example which outputs to register A (so output is appended to register a):
"
"   :redir @A
"   :set nomore
"   :echo 'History'
"   :history
"   :echo 'Scripts loaded'
"   :scriptnames
"   :set nomore
"   :redir END
"   Redirection to a file:
"   :redir > out.txt
"   :registers
"     " any other commands
"   :redir END
"
"   The above writes to the new file out.txt. The command does nothing if that file already exists. To overwrite the file if it exists, use :redir! > out.txt. To create a new file or append to an existing file, use :redir >> out.txt.
"   Store glob results in register a:
"
"   " Clear @a (register a) because need to use A to append.
"   :let @a = ''
"
"   " Append all lines containing 'fred' to register a.
"   :g/fred/y A
"
"   " Append to a file (must use >>).
"   The command uses the :.w command which writes the current line (.) by appending it to file errors.txt.
"   :'a,'b g/^Error/ .w >> errors.txt



"automatically remove trailing whitespace before changing a file
" autocmd FileWritePre    * :call TrimWhiteSpace()
" autocmd FileAppendPre   * :call TrimWhiteSpace()
" autocmd FilterWritePre  * :call TrimWhiteSpace()
" autocmd BufWritePre     * :call TrimWhiteSpace()
" vimwiki
":autocmd bufenter *.wiki set nofen|nmap <F3> <esc>bi[[<ESC>ea]]<ESC>1h|nmap <S-F3> <ESC>eF[F[2xf]2x1h<ESC>
":autocmd bufleave *.wiki nmap <F3> :TagbarToggle<CR>


" See http://stackoverflow.com/questions/890802/vim-disable-press-enter-or-type-command-to-continue-prompt"
"  This is how I dealt with the problem that running an external program through silent messes up the screen in text-mode vim (in my experience, gvim doesn't suffer from this problem):
"
command! -nargs=1 Silent
 \ | execute ':silent !'.<q-args>
 \ | execute ':redraw!'


" Enable spell checking -----
" set spell
"
" Disable spell checking
set nospell
"
" See https://www.andiamo.co.uk/resources/iso-language-codes for the list of available ISO 639-1 language codes
"
"   - using the ENGLISH,GERMAN and FRENCH dictionaries
set spelllang=en,de,fr
"
"   - using the AMERICAN ENGLISH dictionary
" set spelllang=en-us
"
"   - using the FRENCH dictionary
" set spelllang=fr
"
"   - using the GERMAN dictionary
" set spelllang=de
"
" ------   Enable spell checking -----



" Append modeline after last line in buffer.
" Use substitute() instead of printf() to handle '%%s' modeline in LaTeX
" files.
function! AppendModeline()
  let l:modeline = printf(" vim: set ts=%d sw=%d tw=%d %set :",
        \ &tabstop, &shiftwidth, &textwidth, &expandtab ? '' : 'no')
  let l:modeline = substitute(&commentstring, "%s", l:modeline, "")
  call append(line("$"), l:modeline)
endfunction
nnoremap <silent> <Leader>ml :call AppendModeline()<CR>


function! ToggleColorColumn()
    if &colorcolumn
        set colorcolumn=
    else
        set colorcolumn=80
    endif
endfunction



" Plug undo
nnoremap <S-F2> :call LanguageClient_contextMenu()<CR>
nnoremap <F3> :set wrap! linebreak!<CR> <BAR>:echom 'Toggled line wrapping!' <CR> " toggle line wrapping
nnoremap <F4> :NERDTreeToggle<CR>                                     " Toogle NERDTree
nnoremap <F5> :UndotreeToggle<cr>        " nnoremap <F6> :call ToggleSyntax()<CR>
nnoremap <F6> :call ToggleColorColumn()<CR>
inoremap <F7> <C-R>=expand('%:p:h')<CR>
cnoremap <F7> <C-R>=expand('%:p:h')<CR>
nmap <F8> <Plug>(ale_fix)   " Bind F8 to fixing problems with ALE
nnoremap <F9> :let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar><CR> <BAR>:echom 'Erased trailing whitespace !' <CR> " Remove all trailing whitespace (https://vim.fandom.com/wiki/Remove_unwanted_spaces) explicitly by pressing F5


if g:has_goyo
    " Plug undo
    " Plug goyo
    map <ENTER><ENTER> :GoyoToggle<CR>
endif



" You can insert the result of a Vim expression in insert mode using the <C-R>= command.
" See: https://vim.fandom.com/wiki/Mapping_keys_in_Vim_-_Tutorial_(Part_1)
" For example, the following command creates an insert mode map command that inserts the current directory:
"
" :inoremap <F2> <C-R>=expand('%:p:h')<CR>
"
" If you don't want to insert anything then you can return an empty string from the expression.
" For example, you can invoke a function from the insert mode map to perform some operation but return an empty string from the function.
"
" The <C-R>= command doesn't create a new undo point. You can also call Vim functions using the <C-R>= command:
"
" :inoremap <F2> <C-R>=MyVimFunc()<CR>
"
" If the return value of MyVimFunc() is to be ignored and not entered after its call, a ternary operator trick may be used:
"
" :inoremap <F2> <C-R>=MyVimFunc()?'':''<CR>
"
" This will return an empty string, independent of what MyVimFunc() returns.


" set mouse=a " Enables mouse support for all important modes
set mouse=vic    " Disables mouse support for all important modes
set mouse+=a    " Disables mouse support for all important modes

if exists('+ttymouse') "if !has('nvim')
    set ttymouse=sgr " To get mouse working using the Alacritty terminal emulator
endif

if exists('+guioptions')  " Only for gui vim like gvim, ...
    set guioptions-=m     " remove menubar
    set guioptions-=T     " remove toolbar
    set guioptions-=r     " remove right-hand scrollbar
    set guioptions-=L     " remove left-hand scrollbar
endif



" C-s to save file
noremap <silent> <C-S>          :update<CR>
vnoremap <silent> <C-S>         <C-C>:update<CR>
inoremap <silent> <C-S>         <C-O>:update<CR>


" ####### Copy and Paste #######

" Copy only to clipboard register (@+)
" vnoremap <C-c>      "+y

" Copy first to primary selection register (@*), the copy from primary selection register to clipboard register (@+)
vnoremap <C-c>      "*y :let @+=@*<CR>

" Paste content of clipboard register (@+)
noremap      <C-v>      "+p

" By default zoom-toggle is mapped to: <C-W>m (MAXIMIZE)
" To be consistent with tmux we map it to <C-W>z (ZOOM) instead
nmap <silent> <C-W>z <Plug>(zoom-toggle)
nmap <silent> <C-z> <Plug>(zoom-toggle)
" nmap <silent> <A-z> <Plug>(zoom-toggle)


" Remap FZF (fuzzy finder) invocation key to Ctrl-f
" nnoremap <silent> <C-f> :FZF<CR>
nnoremap <silent> <leader>f :FZF<CR>

"set statusline+=%{zoom#statusline()}

" setup nvim as default pager (for man pages)
let $PAGER=''


" Some tricks from https://github.com/bbkane/dotfiles/blob/91ac752ac4a25eca1f3ff271249d2e5878b265b2/nvim/.config/nvim/init.vim#L397



"----------------- CG -------------------
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" sdf sdfdsdf

" Plug Rainbow config {
au FileType c,cpp,objc,objcpp call rainbow#load()
" or just this to enable it globally:
" let g:rainbow_active = 1
" Plug Rainbow config }



" vim-airline plugin config.
" let g:airline_theme='gruvbox'
let g:airline_theme='dark'
let g:airline_powerline_fonts=1 " required if using https://github.com/bling/vim-airline
" vim-airline plugin config.

" vim-bookmarks plugin config.
highlight BookmarkSign ctermbg=NONE ctermfg=160
" highlight BookmarkLine ctermbg=lightgrey ctermfg=black
" highlight BookmarkLine ctermbg=NONE ctermfg=NONE
"
let g:bookmark_sign = '♥'
let g:bookmark_highlight_lines = 1
"
" nnoremap  :BookmarkToggle<CR>
nnoremap <C-d> :BookmarkToggle<CR>
nnoremap <leader>bm :BookmarkToggle<CR>
" vim-bookmarks plugin config.


" vim-tcomment plugin config.
nnoremap <leader>cc :TComment<CR>
vnoremap <leader>cc :TComment<CR>
" vim-tcomment plugin config.



" Use autozimu/LanguageClient-neovim (see https://github.com/autozimu/LanguageClient-neovim)
" Required for operations modifying multiple buffers like rename.
set hidden

let g:LanguageClient_serverCommands = {
    \ 'rust': ['~/.cargo/bin/rustup', 'run', 'stable', 'rls'],
    \ 'javascript': ['/usr/local/bin/javascript-typescript-stdio'],
    \ 'javascript.jsx': ['tcp://127.0.0.1:2089'],
    \ 'python': ['/home/cg/.local/bin/pyls'],
    \ 'ruby':   ['/home/cg/.rbenv/shims/solargraph', 'stdio'],
    \ }
    " \ 'ruby':   ['~/.gem/ruby/2.7.0/bin/solargraph', 'stdio'],
	" \ 'ruby': ['tcp://localhost:7658'],
    " \ 'ruby':   ['~/.gem/ruby/2.7.0/bin/solargraph', 'stdio'],
	" \ 'ruby': ['tcp://localhost:7658'],
    " \ 'python': ['/usr/local/bin/pyls'],
    " \ 'ruby': ['~/.rbenv/shims/solargraph', 'stdio'],

" nnoremap <F5> :call LanguageClient_contextMenu()<CR>
" Or map each action separately

" nnoremap <silent> K :call LanguageClient#textDocument_hover()<CR>
nnoremap <silent> <A-F1> :call LanguageClient#textDocument_hover()<CR>

" nnoremap <silent> <C-S-F3> :call LanguageClient#textDocument_rename()<CR>
nnoremap <silent> <A-F2> :call LanguageClient#textDocument_rename()<CR>  " don't use <F2> (already used by pastetoggle)

" nnoremap <silent> gd :call LanguageClient#textDocument_definition()<CR>
nnoremap <silent> <A-F3> :call LanguageClient#textDocument_definition()<CR>
nnoremap <silent> <A-S-F1> :call LanguageClient#textDocument_definition()<CR>



    " if &softtabstop == 2

" Don't send a stop signal to the server when exiting vim.
" This is optional, but I don't like having to restart Solargraph
" every time I restart vim.
" let g:LanguageClient_loggingFile = expand('~/tmp/LanguageClient.log')
let g:LanguageClient_autoStop = 0
" let g:LanguageClient_trace = 'messages' " Valid options: 'off' | 'messages' | 'verbose'
" let g:LanguageClient_autoStop = 1   " CG; I guess =0 makes only sense when starting via 'solargraph socket' (hence avoids having to restart the solargraph socket server )

" Logging level
" Default: 'WARN'
" Valid options: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR'
" let g:LanguageClient_loggingLevel = 'INFO'

" Configure ruby omni-completion to use the language client:
autocmd FileType ruby setlocal omnifunc=LanguageClient#complete


"Use deoplete.
let g:deoplete#enable_at_startup = 1
set omnifunc=LanguageClient#complete
let g:LanguageClient_diagnosticsEnable = 0


" TODO: Use deoplete#custom#option() (deoplete#sources is deprecated

" let s:default_sources = ['syntax', 'tag', 'buffer', 'file', 'ultisnips']
" let s:default_sources = ['solargraph', 'syntax', 'tag', 'buffer', 'file', 'ultisnips', 'fzf']
let s:default_sources = ['solargraph', 'syntax', 'tag', 'ultisnips']


if g:has_deoplete
    call deoplete#custom#option('sources', {
            \ '_': s:default_sources,
            \ 'go':          [ 'LanguageClient'] + s:default_sources,
            \ 'cs':          [ 'cs'] + s:default_sources,
            \ 'javascript':  [ 'LanguageClient'] + s:default_sources,
            \ 'typescript':  [ 'LanguageClient'] + s:default_sources,
            \ 'ruby':        [ 'LanguageClient'] + s:default_sources,
            \ 'eruby':       [ 'LanguageClient'] + s:default_sources,
            \ 'c':           [ 'clang2'] + s:default_sources,
            \ 'cpp':         [ 'clang2'] + s:default_sources,
            \ 'objc':        [ 'clang2'] + s:default_sources,
            \ 'objcpp':      [ 'clang2'] + s:default_sources,
            \ 'lua':         [ 'omni'] + s:default_sources,
            \ 'java':        [ 'javacomplete2'] + s:default_sources,
            \})"
endif

" Deoplete (completion engine) expects you to use the arrow keys to select
" from suggestion dropdowns while coding
" which isn’t ideal for most Vim users and hence it is recommended
" to map the ctrl-j and ctrl-k bindings to the up and down arrow keys.
" This can be achieved by adding the following lines to your ‘init.vim’
" configuration file (pumvisibible: 'PopUpMenu Visible'):
inoremap <expr> <C-j> pumvisible() ? "\<C-n>" : "\<C-j>"
inoremap <expr> <C-k> pumvisible() ? "\<C-p>" : "\<C-k>"


" To easily activate the plugin you can map it the “<leader>s” key binding by adding the following line to your ‘init.vim’ file.
" Default easymotion-prefix is: <leader><leader>w
" map <leader>s <Plug>(easymotion-prefix)

"Remove all trailing whitespace (https://vim.fandom.com/wiki/Remove_unwanted_spaces)
" implicitly upon buffer write
" The following only changes files with the extension .pl:
" autocmd BufWritePre *.pl %s/\s\+$//e
autocmd BufWritePre * %s/\s\+$//e
" Additionally, a FileType autocommand can be used to restrict the autocmd to certain file types only.
" autocmd FileType c,cpp,java,php autocmd BufWritePre <buffer> %s/\s\+$//e

" vim-startify config {
" Show modified and untracked git files
" https://github.com/mhinz/vim-startify/wiki/Example-configurations

" returns all modified files of the current git repo
" `2>/dev/null` makes the command fail quietly, so that when we are not
" in a git repo, the list will be empty
function! s:gitModified()
    let files = systemlist('git ls-files -m 2>/dev/null')
    return map(files, "{'line': v:val, 'path': v:val}")
endfunction

" same as above, but show untracked files, honouring .gitignore
function! s:gitUntracked()
    let files = systemlist('git ls-files -o --exclude-standard 2>/dev/null')
    return map(files, "{'line': v:val, 'path': v:val}")
endfunction

" function s:foobar()
"     return [
"                 \ { 'line': 'foo', 'cmd': 'echo "FOO!"' },
"                 \ { 'line': 'bar', 'cmd': 'echo "BAR!"' },
"                 \ ]
" endfunction

function! s:list_commits()
    let git = 'git' " let git = 'git -C ~/dotfiles'
    let commits = systemlist(git .' log --oneline | head -n10')
    let git = 'G'. git[1:]
    return map(commits, '{"line": matchstr(v:val, "\\s\\zs.*"), "cmd": "'. git .' show ". matchstr(v:val, "^\\x\\+") }')
endfunction



let g:startify_sessions_dir = '~/.config/nvim/session'

let g:startify_bookmarks = [
        \ {'b': '~/.bashrc'},
        \ {'c': '~/dotfiles/.config/qtile/config.py'},
        \ {'p': '~/dotfiles/vim_plugins.vim'},
        \ {'v': '~/dotfiles/.nvimrc_1'},
        \ ]


let g:startify_lists = [
        \ { 'type': 'files',     'header': ['   Files']            },
        \ { 'type': 'dir',       'header': ['   Current Directory '. getcwd()] },
        \ { 'type': 'sessions',  'header': ['   Sessions']       },
        \ { 'type': 'bookmarks', 'header': ['   Bookmarks']      },
        \ { 'type': function('s:gitModified'),  'header': ['   git modified']},
        \ { 'type': function('s:gitUntracked'), 'header': ['   git untracked']},
        \ { 'type': 'commands',  'header': ['   Commands']       },
        \ { 'header': ['   Commits'],        'type': function('s:list_commits') },
        \ ]
" \ { 'type': function('s:foobar'), 'header': ['foo', ' and', '  bar'] },

let g:startify_commands = [
        \ {'r': ['Vim Reference', 'h ref']},
        \ ]
        " \ ':help reference',
        " \ {'h': 'h ref'},
        " \ {'m': ['My magical function', 'call Magic()']},

let g:startify_files_number = 5 "default: 10

" Usually |v:oldfiles| only gets updated when Vim exits. Using this option updates
" it on-the-fly, so that :Startify is always up-to-date.
let g:startify_update_oldfiles = 0

" If this option is enabled and you start Vim in a directory that contains a
" `Session.vim`, that session will be loaded automatically. Otherwise it will be
" shown as the top entry in the Startify buffer.
"
" The same happens when you |:cd| to a directory that contains a `Session.vim`
" and execute |:Startify|.
"
let g:startify_session_autoload = 1

" This is a list of commands to be executed before saving a session.
let g:startify_session_before_save = [
        \ 'echo "Cleaning up before saving.."',
        \ 'silent! NERDTreeTabsClose'
        \ ]

" When opening a file or bookmark, seek and change to the root directory of the
" VCS (if there is one).
"
" At the moment only git, hg, bzr and svn are supported.
let g:startify_change_to_vcs_root = 0


" A list of Vim regular expressions that is used to filter recently used files.
" See |pattern.txt| for what patterns can be used.
"
" NOTE: Due to the nature of patterns, you can't just use "~/mysecret" but have
" to use "$HOME .'/mysecret.txt'". The former would do something entirely
" different: |/\~|. When using backslashes as path separators, escape them.
" Otherwise using "C:\this\vim\path\is\problematic" would not match what you
" expect, since |/\v| is a pattern, too.

let g:startify_skiplist = [
            \ '\.vimgolf',
            \ '^/tmp',
            \ '/project/.*/documentation',
            \ escape(fnamemodify($HOME, ':p'), '\') .'mysecret.txt',
            \ ]


" The number of spaces used for left padding.
let g:startify_padding_left = 3


" Show <empty buffer> and <quit>.
let g:startify_enable_special = 1


" The maximum number of sessions to display. Makes the most sense together with
" |g:startify_session_sort|.
"
" ------------------------------------------------------------------------------
let g:startify_session_number = 999

" Sort sessions by modification time (when the session files were written)
" rather than alphabetically.
let g:startify_session_sort = 0


" Use any list of strings as indices instead of increasing numbers. If there are
" more startify entries than actual items in the custom list, the remaining
" entries will be filled using the default numbering scheme starting from 0.
"
" Thus you can create your own indexing scheme that fits your keyboard layout.
" You don't want to leave the home row, do you?!
"
" Example:
" >
let g:startify_custom_indices = ['f', 'g', 'h']

let g:startify_custom_header = 'startify#pad(startify#fortune#cowsay())'

" Define your own header.
"
" This option takes a `list of strings`, whereas each string will be put on its
" own line. If it is a simple `string`, it should evaluate to a list of strings.
"
" Helper functions:~
"
"     startify#fortune#quote()       random quote
"     startify#fortune#boxed(...)    random quote in a box
"     startify#fortune#cowsay(...)   random quote in a box + cow
"
" The last two functions optionally take a quote in the list of strings format.
" They also return a list of strings, suitable for this option.
"
"     startify#pad([strings])        pad strings in list according to
"                                    |g:startify_padding_left| or the default of 3
"     startify#center([strings])     center list of strings without removing
"                                    its strings indentations
"
" Example #1:~
" >
"     let g:startify_custom_header = [
"             \ '                                 ________  __ __        ',
"             \ '            __                  /\_____  \/\ \\ \       ',
"             \ '    __  __ /\_\    ___ ___      \/___//''/''\ \ \\ \    ',
"             \ '   /\ \/\ \\/\ \ /'' __` __`\        /'' /''  \ \ \\ \_ ',
"             \ '   \ \ \_/ |\ \ \/\ \/\ \/\ \      /'' /''__  \ \__ ,__\',
"             \ '    \ \___/  \ \_\ \_\ \_\ \_\    /\_/ /\_\  \/_/\_\_/  ',
"             \ '     \/__/    \/_/\/_/\/_/\/_/    \//  \/_/     \/_/    ',
"             \ ]
" <
" Example #2:~
" >
"     let g:startify_custom_header =
"             \ startify#pad(split(system('fortune | cowsay'), '\n'))
" <
" Example #3:~
"
" Let's assume you like the default boxed random quote, but not the ASCII art
" cow. You'd rather have another small ASCII art come before the quote. No
" problem!
" >
"     let g:ascii = [
"           \ '        __',
"           \ '.--.--.|__|.--------.',
"           \ '|  |  ||  ||        |',
"           \ ' \___/ |__||__|__|__|',
"           \ ''
"           \]
"     let g:startify_custom_header = g:ascii + startify#fortune#boxed()
" <
" Looks great! But it's not on the same column as the indices below which makes
" it look awkward. Let's indent the header by 3 spaces:
" >
"     let g:startify_custom_header =
"           \ startify#pad(g:ascii + startify#fortune#boxed())
" <
" Ah, much better! There's only one issue left. If you set
" g:startify_custom_header this way, it will only be done once. Hence spamming
" :Startify will always show the same quote.
"
" If you provide a string to it instead, Startify will evaluate it every time
" :Startify is run:
" >
"     let g:startify_custom_header =
"           \ 'startify#pad(g:ascii + startify#fortune#boxed())'
" <
" Happy customizing!
"
" Also have a look at |startify-faq-08|.
"
" ------------------------------------------------------------------------------
"                                                *g:startify_custom_header_quotes*
"
" If you don't set |g:startify_custom_header|, the internal cowsay implementation
" with predefined random quotes will be used.
"
" To use your own quotes, set this option to a list of quotes. Each quote is
" either another list or a |Funcref| (see |expr-lambda|) that returns a list.
"
" Each element of the inner lists is put on an own line in the custom header.
" >
"     let g:startify_custom_header_quotes = [
"         \ ['quote #1'],
"         \ ['quote #2', 'using', 'three lines'],
"         \ {-> systemlist('echo quote #3')}
"         \ ]
" <
" If you want the predefined quotes as well, use this:
" >
"   let g:startify_custom_header_quotes =
"       \ startify#fortune#predefined_quotes() + [['quote 1', 'quote 2']]
" <
" ------------------------------------------------------------------------------
"                                                       *g:startify_custom_footer*
" >
"     let g:startify_custom_footer = ''
" <
" Same as the custom header, but shown at the bottom of the startify buffer.
"
" ------------------------------------------------------------------------------
"                                                 *g:startify_disable_at_vimenter*
" >
let g:startify_disable_at_vimenter = 0
" <
" Don't run Startify at Vim startup. You can still call it anytime via
" :Startify.
"
" let g:startify_custom_indices = ['f', 'g', 'h']
" -----------------------------------------------------------------------------
" This would result in:
"
"     [f]  /most/recently/used/file1
"     [g]  /most/recently/used/file2
"     [h]  /most/recently/used/file3
"     [0]  /most/recently/used/file4
"     [1]  /most/recently/used/file5
"     [2]  /most/recently/used/file6
"     etc.
"
" If you want numbers to start at 1 instead of 0, you could use this:
" >
"     let g:startify_custom_indices = map(range(1,100), 'string(v:val)')
" <
" NOTE: There is no sanitizing going on, so you should know what you're doing!
"       Avoid using keys from |startify-mappings|.
"
" ------------------------------------------------------------------------------
" endfor
" Delete all buffers when loading or closing a session:
"
"     - When using |startify-:SLoad|.
"     - When using |startify-:SClose|.
"     - When using |g:startify_session_autoload|.
"     - When choosing a session from the Startify buffer.
"
" NOTE: Buffers with unsaved changes are silently ignored.
let g:startify_session_delete_buffers = 1


" Automatically update sessions in two cases:
"
"     - Before leaving Vim
"     - Before loading a new session via :SLoad
"
" This also works for sessions started with:
" >
"     vim -S mysession.vim
let g:startify_session_persistence = 0
"
"
"
" vim-startify config }





" auto-pairs config : https://github.com/jiangmiao/auto-pairs {
let g:AutoPairsFlyMode = 1
let g:AutoPairsShortcutBackInsert = '<M-b>'
" auto-pairs config : https://github.com/jiangmiao/auto-pairs }

" ALE (asunchrnonous linting nf fixing) configuration {
"
"                                                         *ale-fix-configuration*
"
" Synchronous functions and asynchronous jobs will be run in a sequence for
" fixing files, and can be combined. For example:
" >
"   let g:ale_fixers = {
"   \   'javascript': [
"   \       'DoSomething',
"   \       'eslint',
"   \       {buffer, lines -> filter(lines, 'v:val !=~ ''^\s*//''')},
"   \   ],
"   \}
"
" ------------ CG: standardrb is essentially a rubocop wrapper ------------ {
"  that is used to enforce RUBY STANDARD rules/guidelines
"  See https://github.com/testdouble/standard
"  It is preferred by CG over just plain rubocop rules/guidlines.
let g:ale_fixers = {
\   'ruby':        [ 'standardrb'],
\   'javascript':  [ 'eslint'],
\}
" \   'ruby':        [ 'standardrb'],
" \   'ruby':        [ 'rubocop'],
" \   'ruby':        [ 'rufo'],
" \   'ruby':        [ 'sorbet'],
" ------------ CG: standardrb is essentially a rubocop wrapper ------------ }
"
" 'rubocop' - Fix ruby files with rubocop --auto-correct.
" 'rufo' - Fix ruby files with rufo
" 'sorbet' - Fix ruby files with srb tc --autocorrect.
" 'standardrb' - Fix ruby files with standardrb --fix
"
"   ALEFix
" <
" The above example will call a function called `DoSomething` which could act
" upon some lines immediately, then run `eslint` from the ALE registry, and
" then call a lambda function which will remove every single line comment
" from the file.
"
" For buffer-local settings, such as in |g:ale_pattern_options| or in ftplugin
" files, a |List| may be used for configuring the fixers instead.
" >
"   " Same as the above, only a List can be used instead of a Dictionary.
"   let b:ale_fixers = [
"   \   'DoSomething',
"   \   'eslint',
"   \   {buffer, lines -> filter(lines, 'v:val !=~ ''^\s*//''')},
"   \]
"
"   ALEFix
" <
" For convenience, a plug mapping is defined for |ALEFix|, so you can set up a
" keybind easily for fixing files. >
"
" Files can be fixed automatically with the following options, which are all off
" by default.
"
" |g:ale_fix_on_save| - Fix files when they are saved.
let g:ale_fix_on_save = 1    " to launch fixers implicitly (upon buffer SAVE)

" Fixers can be disabled on save with |g:ale_fix_on_save_ignore|. They will
" still be run when you manually run |ALEFix|.
" ALE (asunchrnonous linting and fixing) configuration }



" " SNEAK PLUGIN {
" let g:sneak#label = 1
"
" " case insensitive sneak
" let g:sneak#use_ic_scs = 1
"
" " immediately move to the next instance of search, if you move the cursor sneak is back to default behavior
" let g:sneak#s_next = 1
"
" " remap so I can use , and ; with f and t
" map gS <Plug>Sneak_,
" map gs <Plug>Sneak_;
"
" " Change the colors
" highlight Sneak guifg=black guibg=#00C7DF ctermfg=black ctermbg=cyan
" highlight SneakScope guifg=red guibg=yellow ctermfg=red ctermbg=yellow
"
" " Cool prompts
" let g:sneak#prompt = '🕵'
" " let g:sneak#prompt = '🔎'
"
" " I like quickscope better for this since it keeps me in the scope of a single line
" " map f <Plug>Sneak_f
" " map F <Plug>Sneak_F
" " map t <Plug>Sneak_t
" " map T <Plug>Sneak_T"
" " SNEAK PLUGIN }


" vim-highlightedyank PLUGIN {
let g:highlightedyank_highlight_duration = 350
" A negative number makes the highlight persistent.
" let g:highlightedyank_highlight_duration = -1
" When a new text is yanked or user starts editing, the old highlighting would be deleted.
" Highlight coloring
" If the highlight is not visible for some reason, you can redefine the HighlightedyankRegion highlight group like:
" highlight HighlightedyankRegion cterm=reverse gui=reverse
highlight HighlightedyankRegion ctermbg=white ctermfg=blue guibg=#00C7DF
"
" Note that the line should be located after :colorscheme command execution in your vimrc.
" vim-highlightedyank PLUGIN }



" scalpel/scalpel PLUGIN {
"" The mapping can be suppressed by setting:
"
" ```
" let g:ScalpelMap=0
" ```
"
" Or overridden:
"
" ```
" " Use <Leader>s instead of default <Leader>e:
" nmap <Leader>s <Plug>(Scalpel)
" ```
"
" In any case, Scalpel won't overwrite any pre-existing mapping that you might
" have defined for `<Leader>e`, nor will it create an unnecessary redundant
" mapping if you've already mapped something to `<Plug>(Scalpel)`.
"
" The `:Scalpel` command name can be overridden if desired. For example, you
" could shorten it to `:S` with:
"
" ```
" let g:ScalpelCommand='S'
" ```
"
" Then your Scalpel prompt would look like:
"
" ```
" :S/\v<foo>//
" ```
"
" The command can be entirely suppressed by setting `g:ScalpelCommand` to an
" empty string:
"
" ```
" let g:ScalpelCommand=''
" ```
"
" Finally, all plug-in functionality can be deactivated by setting:
"
" ```
" let g:ScalpelLoaded=1
" ```
"
" in your `~/.vimrc`.
"
" scalpel/scalpel PLUGIN }



" Codi PLUGIN {
" Example configuration for Ruby:
"           \ 'prompt': '^> ',
"           \ 'prompt': '^\(>>>\|\.\.\.\) ',
let g:codi#interpreters = {
            \ 'ruby': {
            \ 'bin': '/home/cg/.rbenv/shims/ruby',
            \ 'prompt': '^> ',
            \ },
            \ }

" Example configuration to change just the Haskell prompt:
" >
"              let g:codi#interpreters = {
"                    \ 'haskell': {
"                        \ 'prompt': '^> ',
"                        \ },
"                    \ }
" <
"              You may also set any of the |per-interpreter| options here. For
"              example, if you want to left-align all JavaScript Codi instances,
"              but keep right-align as the default:
" >
"              let g:codi#interpreters = {
"                    \ 'javascript': {
"                        \ 'rightalign': 0,
"                        \ },
"                    \ }
" <
"              Configuration is deeply applied over the default interpreters.
"              Default value is {}.
"
" Codi PLUGIN }



" vifm PLUGIN }
" To use the plugin copy the vifm.vim file to either the system wide vim/plugin
" directory or into ~/.vim/plugin.
"
" If you would prefer not to use the plugin and it is in the system wide plugin
" directory add >
"
"  let loaded_vifm=1
let loaded_vifm=0
"
" to your ~/.vimrc file.
"
" Configuration variables~
"
"                                                *g:vifm*
" A string variable.  Equals "vifm" by default and specifies path to vifm's
" executable.
"
"                                                *g:vifm_exec_args*
" A string variable that specifies arguments for vifm.  Empty by default.
"
"                                                *g:vifm_term*
" A string variable that specifies command to run GUI terminal.
" By default it's equal to 'xterm -e'.
"
"                                                *g:vifm_embed_term*
" A boolean variable.  When evaluates to true and it's possible to create a
" terminal buffer, it will be used.  Enabled by default inside GUI version.
" Effectively always enabled in neovim.
"
"                                                *g:vifm_embed_split*
let g:vifm_embed_split=1
" A boolean variable.  When evaluates to true and Vifm is embedded in a
" terminal, it will be run inside a new split.  This allows commands to support
" |<mods>| and a |<count>| for controlling the orientation and size of the
" split.  False by default.
"
"                                                *g:vifm_embed_cwd*
"                                                {not on MS-Windows}
" A boolean variable.  When evaluates to true and Vifm is embedded in a
" terminal, vifm will change the active directory in vim while navigating.
" False by default.
"
"                                                *g:vifm_replace_netrw*
" A boolean variable.  When enabling this, don't forget to disable the |netrw|
" plugin (see `:h netrw-noload`), otherwise it can interfere with this plugin
" opening directories using vifm.  Defaults to false.
"
"                                                *g:vifm_replace_netrw_cmd*
" A string variable.  The command to use to open folders when
" g:vifm_replace_netrw is enabled.  Defaults to "Vifm".
"
" Extension for "vifm" filetype~
"
"                                                 *vifm-K*
" K                       Like setting 'keywordprg' to ":help vifm-" (if that
"                         would be possible), but slightly smarter.  Only mapped
"                         in vifm files.
"
" Extension for "mail" filetype~
"
" Vifm's bundle for Vim also includes a tiny mail file type extension that allows
" one to pick files for attachments via Vifm.
"
"                                                *vifm-<localleader>a*
" The function is mapped to <localleader>a key for "mail" filetype buffers only.
" It inserts files picked via Vifm as attachments ("Attach: ...") after
" "Subject" header.
"
" See also~
"
" Repository: https://github.com/vifm/vifm.vim
" Website: https://vifm.info/
" Wiki: https://wiki.vifm.info/
"
" vifm PLUGIN }



" LAST LINE
" vim: set ts=4 sw=4 tw=78 et :
