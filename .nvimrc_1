" __   _(_)_ __ ___  _ __ ___
" \ \ / / | '_ ` _ \| '__/ __|
"  \ V /| | | | | | | | | (__
"   \_/ |_|_| |_| |_|_|  \___|

let g:has_goyo     = match(&rtp, 'goyo') > -1
let g:has_deoplete = match(&rtp, 'deoplete') > -1
let g:has_coc      = match(&rtp, 'coc.nvim') > -1

source $HOME/dotfiles/vim_files/scripts/setup_colorscheme.vim

"---------- https://raw.githubusercontent.com/guoqiao/vimrc/master/vimrc ------------ set nocompatible
syntax on
" for vim 7
" set t_Co=256

if has('termguicolors')
    set termguicolors
endif
syntax enable
filetype indent on

" use stuff from vim.wikia.com example vimrc
" bottom status bar
set showmode
set showcmd
set ruler
set laststatus=2
set scrolloff=5 " Minimal number of screen lines to keep above and below the cursor. (default=10)

set modeline    " Enables modeline
set modelines=5 " VIM shall consider modelines only if a modeline is contained within 5 lines of the top or bottom of file

set shada='100,n$HOME/.config/nvim/files/info/viminfo  "OBSOLETS: set viminfo='100,n$HOME/.config/nvim/files/info/viminfo

"More natural split opening (see
"https://thoughtbot.com/blog/vim-splits-move-faster-and-more-naturally)
" Open new split panes to right and bottom, which feels more natural than Vim’s default:
set splitbelow
set splitright

" left side bar
set number
set relativenumber
" vi doesn't support this
set signcolumn=auto

" middle working area
set lazyredraw
set undolevels=1000
set backspace=eol,start,indent
set iskeyword+=-
" list mode, show tabs and spaces
set list
set listchars=tab:>-,trail:~,extends:>,precedes:<
" this will force cursor jump to new line
" set textwidth=80
set wrap linebreak
set foldlevel=999
" if ! &diff
"     set nowrap nolinebreak foldlevel=0
" endif

set background=dark  " CG: Note LightBackgroundToggle() to toggle via <S-F1>


" file
set hidden
set autoread
set wildignore=*.o,*~,*.pyc
set encoding=utf8
set ffs=unix,dos,mac
" Turn backup off, since most stuff is in git.
" set nobackup
set nowritebackup
set noswapfile
" make it possible to undo when reopen
" i.e. UNDO files are enabled, which means that UNDO will be session persistent
set undofile

set completeopt=menuone,longest " also autocomplete when there is only 1 choice, only insert the longest common text of the matches


" Font configuration
" These are the basic settings to get the font to work (required):
" set guifont=Droid\ Sans\ Mono\ for\ Powerline\ Nerd\ Font\ Complete\ 12

" // indicates that the file has abs path(?)
" set undodir=~/.vim/.undo//

"################################################################################
"save temporary files to /tmp/
"if tmp doesn't exist, make it
" http://stackoverflow.com/a/15317146/2958070
" https://www.reddit.com/r/vim/comments/2jpcbo/mkdir_issue/
" // indicates that the file has abs path(?)
silent! call mkdir($HOME . '/.config/nvim/backup', 'p')
set backupdir=~/.config/nvim/backup//
silent! call mkdir($HOME . '/.config/nvim/swap', 'p')
set directory=~/.config/nvim/swap//
if exists('&undodir') " Vim 7.2 doesn't have this
    silent! call mkdir($HOME . '/.config/nvim/undo', 'p')
    set undodir=~/.config/nvim/undo//
endif
"################################################################################

" :ls :buffers
" :bn(ext) :bp(rev)
" b <Tab>
" b xx<Tab>
"CG set wildmenu
"CG set wildmode=longest:list,full
"CG set wildchar=<Tab> wildcharm=<C-Z>

" No annoying sound on errors
set noerrorbells
set visualbell
set t_vb=
set tm=500

" search
" with ingorecase if all lowercase, otherwise case sensitive
set ignorecase
set smartcase
set hlsearch
set incsearch
set showmatch

" add all files to find path
" :find  FILE -> find FILE and open in current window
" :sfind FILE -> find FILE and open in split
" :tabf  FILE -> find FILE and open in tab
set path=$PWD/**

" enable wildmenu above status bar
set wildmenu  " Use tab to complete stuff in vim menu, Display all matches when tab complete.
" press Tab once: show list for all match as prompt
" press Tab twice: show wildmenu for all match and use Tab again to nav
set wildmode=list:longest,full

" set foldenable
" set foldmethod=indent
" set foldlevelstart=6
" set foldlevel=99
" set foldnestmax=10

" default indent 4-space
set autoindent
set copyindent  " copy the previous indentation on autoindenting
set smartindent
set cindent



" ################################################################################
" # Indent settings

" https://stackoverflow.com/a/1878984/2958070
set tabstop=4       " The width of a TAB is set to 4. Still it is a \t. It is just that
                    " Vim will interpret it to be having a width of 4.
set softtabstop=4   " Sets the number of columns for a TAB
set shiftwidth=4    " Indents will have a width of 4
set shiftround      " use multiple of shiftwidth when indenting with '<' and '>'
set expandtab       " Expand TABs to spaces
set smarttab        " When on, a <Tab> in front of a line inserts blanks according to 'shiftwidth'.
                    " 'tabstop' or 'softtabstop' is used in other places.

" Custom indent settings per filetype
augroup custom_filetype
    autocmd!
    autocmd BufNewFile,BufRead *.go setlocal noexpandtab shiftwidth=4 softtabstop=4 tabstop=4

    " Only use tabs in gitconfig
    " https://stackoverflow.com/questions/3682582/how-to-use-only-tab-not-space-in-vim
    autocmd BufRead,BufNewFile .gitconfig setlocal autoindent noexpandtab tabstop=8 shiftwidth=8
    autocmd BufRead,BufNewFile Vagrantfile set filetype=ruby

    " Don't highlight whitespace in xmlm html documents (as it would be done too often, see https://nvie.com/posts/how-i-boosted-my-vim/ )
    autocmd filetype html,xml set listchars-=tab:>.

    " https://superuser.com/a/907889/643441
    autocmd filetype crontab setlocal nobackup nowritebackup

    " Use 2 spaces to indent in these
    " autocmd FileType html,javascript,json,ruby,typescript,yaml setlocal shiftwidth=2 softtabstop=2
    autocmd FileType javascript,json,ruby,typescript setlocal shiftwidth=2 softtabstop=2
    autocmd FileType html,yaml   setlocal shiftwidth=2 softtabstop=2 tabstop=2 expandtab

    " c indent 8-space
    autocmd FileType c      setlocal shiftwidth=8 softtabstop=8 tabstop=8 noexpandtab

    " " frontend indent 2-space
    " autocmd FileType html,yaml   setlocal shiftwidth=2 softtabstop=2 tabstop=2 expandtab
    " " c indent 8-space
    " autocmd FileType c      setlocal shiftwidth=8 softtabstop=8 tabstop=8 noexpandtab
augroup END


" TODO: clean up indent settings ( https://stackoverflow.com/a/1878983/2958070 )
function! IndentSpacesToggle()
    if &softtabstop == 2
        setlocal tabstop=4
        setlocal shiftwidth=4
        setlocal softtabstop=4
        setlocal expandtab
        echom "#spaces per indent = 4"
    else
        setlocal tabstop=2
        setlocal shiftwidth=2
        setlocal softtabstop=2
        setlocal expandtab
        echom "#spaces per indent = 2"
    endif
endfunction

command! IndentSpacesToggle call IndentSpacesToggle()
command! AppendModeline call AppendModeline()

" Sometimes I dont want to indent (yaml files in particular)
command! StopIndenting setl noai nocin nosi inde=

" Set Visual Studio style indents
command! VSIndentStyle set noexpandtab shiftwidth=4 softtabstop=4 tabstop=4
" ###############################################################################

set history=9999
set tags=tags

nnoremap ; :

" nnoremap 0 ^
" nnoremap <Space> $

" nnoremap B ^
" nnoremap E $

" Yank from the cursor to the end of the line, to be consistent with C and D.
nnoremap Y y$

" Treat long lines as break lines (useful when moving around in them)
nnoremap j gj
nnoremap k gk

"################################################################################
" Smart way to move between windows
" This is now on plug in https://github.com/christoomey/vim-tmux-navigator
" which makes it also work in tmux split settings
nnoremap <C-n> <ESC><C-w><C-w>
nnoremap <C-j> <ESC><C-w><C-j>
nnoremap <C-k> <ESC><C-w><C-k>
nnoremap <C-l> <ESC><C-w><C-l>
nnoremap <C-h> <ESC><C-w><C-h>

" CG: Disabled due to conflict with tmux mapping (instead use <leader>+ and <leader>-)
nnoremap <silent> <C-LEFT> :vertical resize +5<CR>
nnoremap <silent> <C-RIGHT> :vertical resize -5<CR>

nnoremap <silent> <C-UP> :resize +5<CR>
nnoremap <silent> <C-DOWN> :resize -5<CR>


" nnoremap <LEFT> :echom 'LEFT KEY_DISABLED_BY_CG'<CR><C-W><
" nnoremap <RIGHT> :echom 'RIGHT KEY_DISABLED_BY_CG'<CR><C-W>>
nnoremap <LEFT> :echom 'LEFT KEY_DISABLED_BY_CG'<CR>
nnoremap <RIGHT> :echom 'RIGHT KEY_DISABLED_BY_CG'<CR>
nnoremap <DOWN> :echom 'DOWN KEY_DISABLED_BY_CG'<CR>
nnoremap <UP> :echom 'UP KEY_DISABLED_BY_CG'<CR>
" Smart way to manage tabs
nnoremap tl :tabnext<CR>
nnoremap th :tabprev<CR>
nnoremap tn :tabnew<CR>
nnoremap tc :tabclose<CR>
nnoremap tm :tabmove<CR>
nnoremap to :tabonly<CR>



" let mapleader = "\<Space>"
" let mapleader = " "
let mapleader = ","
let maplocalleader = ","
"
" leader affects all of vim, localleader is meant for a specific buffer, you generally use it based on a filetype. Using a localleader you can use the same leader-mapping for (slightly) different actions.
"
" Experiment with Steve Losh: http://learnvimscriptthehardway.stevelosh.com/chapters/06.html
"
" or read more about it in the helpfiles:
"
" http://vimdoc.sourceforge.net/htmldoc/map.html#mapleader
" level 1
" jumpwah
" noremap <down> :execute ":bufdo! %d \| xa!"<cr>2 points ·
" 4 years ago
"
" :help localleader?
" level 1
" marklgr
" vimgor: good bot1 point ·
" 4 years ago
"
" <LocalLeader> is just like <Leader>, except that it uses "maplocalleader" instead of "mapleader".
" <LocalLeader> is to be used for mappings which are local to a buffer.
" Example: > :map <buffer> <LocalLeader>A oanother line<Esc>
"
" In a global plugin <Leader> should be used and in a filetype plugin
" <LocalLeader>.  "mapleader" and "maplocalleader" can be equal.  Although, if
" you make them different, there is a smaller chance of mappings from global
" plugins to clash with mappings for filetype plugins.  For example, you could
" keep "mapleader" at the default backslash, and set "maplocalleader" to an
" underscore.


nnoremap <leader>0 :Tabularize /=<CR>
vnoremap <leader>0 :Tabularize /=<CR>
nnoremap <leader>= :Tabularize /=<CR>
vnoremap <leader>= :Tabularize /=<CR>

" nnoremap <leader>- :Tabularize /-<CR>
" vnoremap <leader>- :Tabularize /-<CR>
nnoremap <silent> <leader>+ :vertical resize +5<CR>
nnoremap <silent> <leader>- :vertical resize -5<CR>

" nnoremap <leader>. :Tabularize /:<CR>
" vnoremap <leader>. :Tabularize /:<CR>
nnoremap <leader>: :Tabularize /:<CR>
vnoremap <leader>: :Tabularize /:<CR>

" nnoremap <leader>+ :Tabularize /\<CR>
" vnoremap <leader>+ :Tabularize /\<CR>
nnoremap <leader>\ :Tabularize /\<CR>
vnoremap <leader>\ :Tabularize /\<CR>

let loaded_matchparen = 1 " disable math parenthiese

"################################################################################
if !has("gui_running")
    set confirm "open a save dialog when quitting
endif

if exists('&inccommand')
    set inccommand=split
endif


" map j to gj and k to gk, so line navigation ignores line wrap
nnoremap j gj
nnoremap k gk

nnoremap <leader>V ggVG
" nnoremap <C-A> ggVG

" Tab through buffers (writes to them...)
nnoremap  <silent>   <tab>  :if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR>:bnext<CR>
nnoremap  <silent> <s-tab>  :if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR>:bprevious<CR>



" TERMINAL MODE mappings {
" To map <Esc> to exit terminal-mode: >
tnoremap <Esc> <C-\><C-n>

" To simulate |i_CTRL-R| in terminal-mode: >
tnoremap <expr> <C-R> '<C-\><C-N>"'.nr2char(getchar()).'pi'

" To use `ALT+{h,j,k,l}` to navigate windows from any mode: >
tnoremap <A-h> <C-\><C-N><C-w>h
tnoremap <A-j> <C-\><C-N><C-w>j
tnoremap <A-k> <C-\><C-N><C-w>k
tnoremap <A-l> <C-\><C-N><C-w>l
inoremap <A-h> <C-\><C-N><C-w>h
inoremap <A-j> <C-\><C-N><C-w>j
inoremap <A-k> <C-\><C-N><C-w>k
inoremap <A-l> <C-\><C-N><C-w>l
nnoremap <A-h> <C-w>h
nnoremap <A-j> <C-w>j
nnoremap <A-k> <C-w>k
nnoremap <A-l> <C-w>l
" TERMINAL MODE mappings }



" Use bash highlighting instead of sh highlighting
" let g:is_posix = 1
let g:is_bash = 1

" Make some stuff uncopyable on HTML output
" :help :TOhtml
let g:html_prevent_copy = "fn"


" To use the clipboard on linux, install xsel
if has('clipboard')
    "Use system CLIPBOARD by as default yank register
    " ==> vapy  will copy a paragraph info CLIPBOARD
    " (otherwise I would need to : vap"+y to address CLIPBOARD register explicitly ("+)
    set clipboard^=unnamedplus,unnamed
endif

" Map jk to <Esc> to preent having to leave the home row
" inoremap jk <ESC>

" save without sudo vim
cmap w!! w !sudo tee > /dev/null %

if has("nvim")
    tnoremap <Esc> <C-\><C-n>
    tnoremap fd  <C-\><C-n>
    " split settings
    " This doesn't work with my tmux plugin
    " go to next bufer
    tnoremap <C-n> <C-\><C-n><C-w><C-w>
    " Map Ctrl+ <motion> to <Terminal escape> + < Window Control> + <Motion>
    tnoremap <C-j> <C-\><C-n><C-w><C-j>
    tnoremap <C-k> <C-\><C-n><C-w><C-k>
    tnoremap <C-l> <C-\><C-n><C-w><C-l>
    tnoremap <C-h> <C-\><C-n><C-w><C-h>
    " open terminal in vertical split instead of new buffer
    command! Term :vert sp | term
    " Hopefully, this keeps buffers when I switch windows
    autocmd TermOpen * set bufhidden=hide
endif

" disable error bells
if !has("nvim")
    set nocompatible
    set visualbell t_vb=
endif


" http://stackoverflow.com/a/18444962/2958070
" custom file templates
augroup templates
    au!
    autocmd BufNewFile *.* silent! execute '0r ~/.config/nvim/templates/skeleton.'.expand("<afile>:e")
augroup END

function! ShowFuncName()
    let lnum = line(".")
    let col = col(".")
    echohl ModeMsg
    echo getline(search("^[^ \t#/]\\{2}.*[^:]\s*$", 'bW'))
    echohl None
    call search("\\%" . lnum . "l" . "\\%" . col . "c")
endfunction
command! ShowFuncName call ShowFuncName()

command! -nargs=1 Help vert help <args>

function Open(open_me)
    let open_me = expand(a:open_me)
    if has('win32')
        execute "silent !start " . a:open_me
    elseif has('mac')
        execute "silent !open " . a:open_me
    else
        execute "silent !xdg-open " . a:open_me
    endif
endfunction
command! Open call Open('%')
command! OpenDir call Open('%:p:h')


"################################################################################

"see http://vimcasts.org/episodes/the-edit-command/
" expand('%:h') -->  <dirname(CURRENT_FILE)>
" expand('%:p') -->  <CURRENT_FILE>
"e.g:  /tmp/.nvimrc_1  --> /tmp
"
" In command mode:  '%%'  -expands_to->  <dirname(CURRENT_FILE)>
cnoremap %% <C-R>=expand('%:h').'/'<cr>
" In command mode:   -expands-to->   <CURRENT_FILE>  (provided by fugitive
" plugin)


map <leader>ee :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%

noremap <leader>h :noh<CR>
noremap <leader>w :w<CR>


" noremap <leader>e :e!<CR>   " mapping already used by default by scalpel PLUGIN
noremap <leader>x :x<CR>
noremap <leader>zz :wqa<CR> " write and quit all buffers

" noremap <leader>q :q<CR>
" nnoremap Q <nop>  " Dont enter EX-mode by presssing 'Q' (default vim behavior)
nnoremap Q :call QuickfixToggle()<cr>

let g:quickfix_is_open = 0
function! QuickfixToggle()
    if g:quickfix_is_open
        cclose
        let g:quickfix_is_open = 0
        " go back to the window/split where we came from
        " before entering the QUICKFIX window
        execute g:quickfix_return_to_window . "wincmd w"
    else
        let g:quickfix_return_to_window = winnr()
        copen
        let g:quickfix_is_open = 1
    endif
endfunction



map <S-F1> :call LightBackgroundToggle()<CR>

function! LightBackgroundToggle()
    if &background ==# 'dark'
        set background=light
    else
        set background=dark
    endif
endfunction
command! LightBackgroundToggle call LightBackgroundToggle()




" ##########  goyo and limelight {
" let g:goyo_width  = 90   " (default: 80)
" let g:goyo_height = '90%' " (default: 85%)
" let g:goyo_linenr = 0     " (default: 0)

let g:limelight_conceal_ctermfg = 'gray'
let g:limelight_conceal_ctermfg = 240

function! s:goyo_enter()
  if executable('tmux') && strlen($TMUX)
    silent !tmux set status off
    silent !tmux list-panes -F '\#F' | grep -q Z || tmux resize-pane -Z
  endif
  set noshowmode
  set noshowcmd
  set nocursorline
  set scrolloff=999
  Limelight
  " ...
endfunction

function! s:goyo_leave()
  if executable('tmux') && strlen($TMUX)
    silent !tmux set status on
    silent !tmux list-panes -F '\#F' | grep -q Z && tmux resize-pane -Z
  endif
  set cursorline
  set showmode
  set showcmd
  set scrolloff=5
  Limelight!
  " ...
endfunction


let g:goyo_is_open = 0
function! s:goyo_toggle()
    if g:goyo_is_open
        Goyo!
		" call <SID>goyo_leave()
        let g:goyo_is_open = 0
    else
		" call <SID>goyo_enter()
        Goyo 90x90%
        let g:goyo_is_open = 1
    endif
endfunction


autocmd! User GoyoEnter nested call <SID>goyo_enter()
autocmd! User GoyoLeave nested call <SID>goyo_leave()

command! GoyoToggle :call <SID>goyo_toggle()

" ##########  goyo and limelight }



nnoremap <leader>b  :e $HOME/dotfiles/.bashrc<CR>
nnoremap <leader>bb :ls<CR>:buffer<Space>
nnoremap <leader>v  :e $HOME/dotfiles/.nvimrc_1<CR>
nnoremap <leader>t  :e /home/cg/dotfiles/.tmux.conf<CR>
noremap  <leader>p  :e $HOME/dotfiles/vim_plugins.vim<CR>
noremap  <leader>sv :source $HOME/.nvimrc_1<CR>
noremap  <leader>sp :source $HOME/dotfiles/vim_plugins.vim<CR>
noremap  <leader>sc :source %<CR>

noremap  <leader>vv :e $MYVIMRC<CR>

if filereadable(expand("~/workspace/nvim__last_session.vim"))
    nnoremap <leader>ss :mksession! $HOME/workspace/nvim__last_session.vim
else
    nnoremap <leader>ss :mksession! $HOME/.config/nvim/last_session.vim
endif

" reload vimrc
" command! ReloadVimrc source $MYVIMRC
" command! EditVimrc :edit $MYVIMRC
command! ReloadVimrc source $MYVIMRC
command! EditVimrc :edit $MYVIMRC
" command!  -range=% -nargs=0 -bar ExpandTabs :retab<CR>
command! ExpandTabs :retab<CR>


set pastetoggle=<F2>

" set t_Co=256
set guioptions-=r  "remove right hand scrollbar
set guioptions-=L  "remove left hand scrollbar

" add transparency, must be after colorscheme
function! InstallVimPlug()
    if empty(glob("~/.config/nvim/autoload/plug.vim"))
        if executable('curl')
            let plugpath = "https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"
            silent exec "!curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs " . plugpath
            redraw!
            echom "Now restart the editor"
        else
            echom "Install curl"
        endif
    else
        echom "vim-plug installed!"
    endif
endfunction
command! InstallVimPlug call InstallVimPlug()

if executable("rg")
    set grepprg=rg\ --vimgrep
endif

if executable('cloc')
    command! VimConfigStats exec '!cloc --by-file-by-lang --exclude-dir=syntax,bundle,autoload,templates ~/.config/nvim'
    command! Cloc !cloc %
endif

" TODO: checkout :h formatexpr and :h formatprg

if executable('python')
    command! JSONFormat %!python -m json.tool
endif

" Format current Python file
if executable('black')
    " https://github.com/psf/black/issues/431
    command! BlackFormat %!black -q - < %
endif

if executable('gofmt')
    command! GoFormat %!gofmt %
endif

if executable('terraform')
    command! TerraFormat %!terraform fmt -no-color - < %
endif

" use zg to add word to word-list
" ]s and [s jump to misspelled words
function! SpellCheckToggle()
    if &spell
        setlocal nospell
        setlocal complete-=kspell
    else
        setlocal spell spelllang=en_us
        " turn on auto-completion with C-n, C-p
        setlocal complete+=kspell
    endif
endfunction
command! SpellCheckToggle call SpellCheckToggle()
" format existing text by selecting it and using `gq`

command! SearchHLToggle :setlocal invhlsearch

function! NumberToggle()
    if &number
        setlocal nonumber
    else
        setlocal number
    endif
endfunction
command! NumberToggle call NumberToggle()

" TODO: optional filename to save to
function! WriteHTML()
    silent exec "TOhtml"
    silent exec "w"
    silent exec "q"
endfunction

" http://superuser.com/a/277326/643441
command! TouchFile :call writefile([], expand("<cfile>"), "t")

function! UpByIndent()
    norm! ^
    let start_col = col(".")
    let col = start_col
    while col >= start_col
        norm! k^
        if getline(".") =~# '^\s*$'
            let col = start_col
        elseif col(".") <= 1
            return
        else
            let col = col(".")
        endif
    endwhile
endfunction
command! UpByIndent :call UpByIndent()

" http://stackoverflow.com/a/749320/2958070
" exit with :q or :diffoff
function! s:DiffWithSaved()
    let filetype=&ft
    diffthis
    vnew | r # | normal! 1Gdd
    diffthis
    exe "setlocal bt=nofile bh=wipe nobl noswf ro ft=" . filetype
endfunction
command! DiffSaved call s:DiffWithSaved()

command! FullPath echo expand('%:p')

function! SetExecutableBit()
    let fname = expand("%:p")
    checktime
    execute "au FileChangedShell " . fname . " :echo"
    silent !chmod a+x %
    checktime
    execute "au! FileChangedShell " . fname
endfunction
command! SetExecutableBit call SetExecutableBit()

" The 'e' on the end of the substitute ignores errors
" -range=% means without a visual selection the whole buffer is selected
"  Special thanks to a @jfim for the link substitution line
"  Note that top level lists can be represented by ^-, not ^*
"  TODO: handle ^# substitution in code blocks
command! -range=% -nargs=0 -bar MarkdownToJira
    \ :<line1>,<line2>s:^  - :** :e
    \ | <line1>,<line2>s:^    - :*** :e
    \ | <line1>,<line2>s:^```:{noformat}:e
    \ | <line1>,<line2>s:^# :h1. :e
    \ | <line1>,<line2>s:^## :h2. :e
    \ | <line1>,<line2>s:^### :h3. :e
    \ | <line1>,<line2>s: `: {{:eg
    \ | <line1>,<line2>s:^`:{{:e
    \ | <line1>,<line2>s:` :}} :eg
    \ | <line1>,<line2>s:`$:}}:eg
    \ | <line1>,<line2>s:`\.:}}.:eg
    \ | <line1>,<line2>s:^\d\+\. :# :e
    \ | <line1>,<line2>s/\v\[([^\]]*)\]\(([^\)]*)\)/[\1|\2]/ge

" TODO: add filtype on top?
" NOTE: add bottom one first to not mess up what's <line2>
command! -range=% -nargs=0 -bar AddCodeFence
    \ :<line2>s:$:\r```:
    \ | <line1>s:^:```\r:

" https://unix.stackexchange.com/a/58748/185953
" <line1>,<line2>VisualSelect
command! -range VisualSelect normal! <line1>GV<line2>G

" One thing I can do is hit Ctrl + x, Ctrl + e to open up my $EDITOR (NeoVim)
" to edit the long command (Bash 1-liner)
" . Now I can use all of Vim’s tricks to edit my command.
" But I’m still faced with the problem of it being all in one line,
"  hard to read and not super nice to edit.
"
" Now, when calling the FormatShellCmd function AFTER having launched vim by pressing  inside BASH
" The formerly long 1-liner will be split and nicely presented in multiples lines inside the vim buffer and can be edited easily
" and when the vim instance is closed the edited long command will be executed within the BASH instance that formerly spawnwd VIM (after pressing )
" See https://www.bbkane.com/2020/04/14/Long-Shell-Oneliners-Without-the-Pain.html
command! -range FormatShellCmd <line1>!format_shell_cmd.py

" Mostly for ordered lists in Markdown
" https://stackoverflow.com/a/4224454/2958070
command! -nargs=0 -range=% NumberLines <line1>,<line2>s/^\s*\zs/\=(line('.') - <line1>+1).'. '
command! -nargs=0 -range=% UnNumberLines <line1>,<line2>s/\d\+\. //g

" https://askubuntu.com/a/686806/483521
command! InsertDate :execute 'norm i' .
    \ substitute(system("date '+%a %b %d - %Y-%m-%d %H:%M:%S %Z'"), '\n\+$', '', '')

" Finally, load secretive stuff not under version control
if !empty(glob("~/.config/nvim_local.vim"))
    source ~/.config/nvim_local.vim
    command! EditNvimLocal :edit ~/.config/nvim_local.vim
endif

"################################################################################
"################################################################################
"################################################################################
"################################################################################

highlight Normal guibg=NONE ctermbg=NONE
highlight ColorColumn ctermbg=LightCyan guibg=darkgrey
" set colorcolumn=80
set colorcolumn=      " type:string, defaults to ''  ==> disabled by default (can be enabled by F6 toggler)
"let &colorcolumn="80,".join(range(120,999),",")

" " cursor shape and color
" highlight Cursor guifg=white guibg=black
" highlight iCursor guifg=white guibg=steelblue
" set guicursor=n-v-c:block-Cursor
" set guicursor+=i:ver100-iCursor
" set guicursor+=n-v-c:blinkon10
" set guicursor+=i:blinkwait10
"
"

highlight Cursor guifg=white guibg=black ctermfg=red ctermbg=green
highlight iCursor guifg=red guibg=steelblue ctermfg=red ctermbg=NONE
set guicursor=n-v-c:block-Cursor
set guicursor+=i:ver100-iCursor
set guicursor+=n-v-c:blinkon1
"set guicursor+=i:blinkwait10


" Uncomment the following line if cursorline should always be highlighted
" set cursorline  " underlines current line
" set nocursorline  " underlines current line

" Only show cursorline in insert mode
" with yellow underline
" hi CursorLine gui=underline cterm=underline ctermfg=yellow guifg=yellow
" hi CursorLine gui=underline cterm=underline ctermfg=None guifg=None ctermbg=None
" hi CursorLine gui=underline cterm=underline ctermfg=None guifg=None
" hi CursorLine gui=None cterm=None ctermfg=black ctermbg=grey
" hi CursorLine gui=None cterm=None ctermfg=black ctermbg=lightgrey
" hi CursorLine cterm=reverse gui=reverse
" hi CursorLine gui=None cterm=None ctermfg=black ctermbg=darkgrey   " CG: used e.g. for 'textDocument_hover' (<A-F1>)
hi CursorLine gui=None guibg=#121212 guifg=#cc5fff  cterm=None ctermfg=black ctermbg=darkgrey   " CG: used e.g. for 'textDocument_hover' (<A-F1>)
" hi CursorLine gui=None guibg=blue guifg=yellow blue cterm=None ctermfg=black ctermbg=darkgrey   " CG: used e.g. for 'textDocument_hover' (<A-F1>)

" autocmd InsertEnter * set cursorline
" autocmd InsertLeave * set nocursorline

autocmd! bufwritepost vimrc source %
command! FJ % !python3 -m json.tool


function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction

function! VisualSelection(direction, extra_filter) range
    let l:saved_reg = @"
    execute "normal! vgvy"

    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")

    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.' . a:extra_filter)
    elseif a:direction == 'replace'
        call CmdLine("%s" . '/'. l:pattern . '/')
    elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
    endif

    let @/ = l:pattern
    let @" = l:saved_reg
endfunction

" Visual mode pressing * or # searches for the current selection
" Super useful! From an idea by Michael Naumann
vnoremap <silent> * :call VisualSelection('f', '')<CR>
vnoremap <silent> # :call VisualSelection('b', '')<CR>
" When you press <leader>r you can search and replace the selected text
vnoremap <silent> <leader>r :call VisualSelection('replace', '')<CR>


" goog vim reference
" https://www.tutorialdocs.com/article/vim-configuration.html

" load plugins if available
if filereadable(expand("~/.vim/pack/devpy/vimrc.pack"))
  source ~/.vim/pack/devpy/vimrc.pack
endif




"----------------- CG -------------------

""""""" See http://www.ibm.com/developerworks/linux/library/l-vim-script-1/index.html
"Listing 1. Toggling syntax highlighting
function! ToggleSyntax()
   if exists("g:syntax_on")
      syntax off
   else
      syntax enable
   endif
endfunction

nmap <silent>  <SPACE>s  :call ToggleSyntax()<CR>

" u is undo ==> U is redo
nmap U :redo<CR>


function! CapitalizeCenterAndMoveDown()
   s/\<./\u&/g   "Built-in substitution capitalizes each word
   center        "Built-in center command centers entire line
   +1            "Built-in relative motion (+1 line down)
endfunction

nmap <silent>  <SPACE>c  :call CapitalizeCenterAndMoveDown()<CR>

"Highlighting frequently misused words (see )

"Create a text highlighting style that always stands out...
highlight STANDOUT term=bold cterm=bold gui=bold ctermfg=yellow ctermbg=blue

"List of troublesome words...
let s:words = [
             \ "it's",  "its",
             \ "your",  "you're",
             \ "were",  "we're",   "where",
             \ "their", "they're", "there",
             \ "to",    "too",     "two"
             \ ]

"Build a Vim command to match troublesome words...
let s:words_matcher
\ = 'match STANDOUT /\c\<\(' . join(s:words, '\|') . '\)\>/'

"Toggle word checking on or off...
" Word checking is enabled by setting Vim's match command. A match expects a
" text-highlighting specification (STANDOUT in this example), followed by a
" regular expression that specifies which text to highlight. In this case,
" that regex is constructed by OR'ing together all of the words specified in
" the script's s:words list variable (that is: join(s:words, '\|')). That set
" of alternatives is then bracketed by case-insensitive word boundaries
" (\c\<\(...\)\>) to ensure that only entire words are matched, regardless of
" capitalization."
function! WordCheck ()
   "Toggle the flag (or set it if it doesn't yet exist)...
   let w:check_words = exists('w:check_words') ? !w:check_words : 1

   "Turn match mechanism on/off, according to new state of flag...
   if w:check_words
      exec s:words_matcher
   else
      match none
   endif
endfunction

"Use ;p to toggle checking...

nmap <silent>  <SPACE>wc  :call WordCheck()<CR>


""""""" See http://www.ibm.com/developerworks/linux/library/l-vim-script-1/index.html
"Scripting in Insert mode
"Vimscripting is by no means restricted to Normal mode. You can also use the imap or iabbrev commands to set up key-mappings or abbreviations that can be used while inserting text. For example:
"imap <silent> <C-D><C-U> [due: <C-R>=strftime("%d.%m.%y")]<CR>
imap <silent> <C-D><C-U> [due:  <C-R>=strftime("%d.%m.%Y") <CR>]<SPACE><SPACE>
imap <silent> <C-D><C-D> <C-R>=strftime("%02e %b. %Y")<CR>
imap <silent> <C-T><C-T> <C-R>=strftime("%02l:%M %p")<CR>
imap <silent> <C-D><C-T> <C-R>=strftime("%02e %b. %Y") . strftime("%02l:%M %p")<CR>
"With these mappings in your .vimrc, typing CTRL-D twice while in Insert mode causes Vim to call its built-in strftime() function and insert the resulting date, while double-tapping CTRL-T likewise inserts the current time.
"You can use the same general pattern to cause an insertion map or an abbreviation to perform any scriptable action. Just put the appropriate Vimscript expression or function call between an initial <C-R>= (which tells Vim to insert the result of evaluating what follows) and a final <CR> (which tells Vim to actually evaluate the preceding expression). Remember, though, that <C-R> (Vim's abbreviation for CTRL-R) is not the same as <CR> (Vim's abbreviation for a carriage return).
"For example, you could use Vim's built-in getcwd() function to create an abbreviation for the current working directory, like so:
iabbrev <silent> CWD <C-R>=getcwd()<CR>
"Or you could embed a simple calculator that can be called by typing CTRL-C during text insertions:
imap <silent> <C-C> <C-R>=string(eval(input('Calculate: ')))<CR>
"Here, the expression:
"string( eval( input("Calculate: ") ) )
"first calls the built-in input() function to request the user to type in their calculation, which input() then returns as a string. That input string is then passed to the built-in eval(), which evaluates it as a Vimscript expression and returns the result. Next, the built-in string() function converts the numeric result back to a string, which the key-mapping's <C-R>= sequence is then able to insert.


" In INSERT mode:
" when line is ending in word 'cg', the 'cg' will be subsituted with 'Chrisian Günther'
" when line is ending in word 'auth', the 'auth' will be subsituted with 'Author: Chrisian Günther'
"
iabbrev <silent> cg<C-R> Christian Günther<CR>
iabbrev <silent> auth<C-R> Author: Christian Günther<CR>



""""""" See http://www.ibm.com/developerworks/linux/library/l-vim-script-1/index.html

"Listing 11. Improving vertical copies to ignore blank lines
"  The LookUpwards() function first determines which on-screen column (or "virtual column") the insertion point is currently in, using the built-in virtcol() function. The '.' argument specifies that you want the column number of the current cursor position:
"  let column_num = virtcol('.')
"  LookUpwards() then uses the built-in search() function to look backwards through the file from the cursor position:
"  let target_pattern = '\%' . column_num . 'v.'
"  let target_line_num = search(target_pattern . '*\S', 'bnW')
"  The search uses a special target pattern (namely: \%column_numv.*\S) to locate the closest preceding line that has a non-whitespace character (\S) at or after (.*) the cursor column (\%column_numv). The second argument to search() is the configuration string bnW, which tells the function to search backwards but not to move the cursor nor to wrap the search. If the search is successful, search() returns the line number of the appropriate preceding line; if the search fails, it returns zero.
"  The if statement then works out which character—if any—is to be copied back down to the insertion point. If a suitable preceding line was not found, target_line_num will have been assigned zero, so the first return statement is executed and returns an empty string (indicating "insert nothing").
"  If, however, a suitable preceding line was identified, the second return statement is executed instead. It first gets a copy of that preceding line from the current editor buffer:
"  return matchstr(getline(target_line_num), target_pattern)
"  It then finds and returns the one-character string that the previous call to search() successfully matched:
"  return matchstr(getline(target_line_num), target_pattern)
"  Having implemented this new vertical copy behavior inside LookUpwards(), all that remains is to override the standard CTRL-Y command in Insert mode, using an imap:
"  imap <silent> <C-Y> <C-R><C-R>=LookUpwards()<CR>
"  Note that, whereas earlier imap examples all used <C-R>= to invoke a Vimscript function call, this example uses <C-R><C-R>= instead. The single-CTRL-R form inserts the result of the subsequent expression as if it had been directly typed, which means that any special characters within the result retain their special meanings and behavior. The double-CTRL-R form, on the other hand, inserts the result as verbatim text without any further processing.
"  Verbatim insertion is more appropriate in this example, since the aim is to exactly copy the text above the cursor. If the key-mapping used <C-R>=, copying a literal escape character from the previous line would be equivalent to typing it, and would cause the editor to instantly drop out of Insert mode.

"Locate and return character "above" current cursor position...
function! LookUpwards()
   "Locate current column and preceding line from which to copy...
   let column_num      = virtcol('.')
   let target_pattern  = '\%' . column_num . 'v.'
   let target_line_num = search(target_pattern . '*\S', 'bnW')

   "If target line found, return vertically copied character...

   if !target_line_num
      return ""
   else
      return matchstr(getline(target_line_num), target_pattern)
   endif
endfunction


"Reimplement CTRL-Y within insert mode...
" imap <silent>  <C-Y>  <C-R><C-R>=LookUpwards()<CR>
" CG: <C-Y> is already mapped by EMMET plugin ==> Map <leader>y instead
imap <silent>  <leader>y  <C-R><C-R>=LookUpwards()<CR>


""""""" See http://vim.wikia.com/wiki/VimTip315
"The following lines (in your vimrc) implement smart home for normal, visual, operator pending, and insert modes.
"The first line is an expression mapping for normal, visual, and operator pending modes. The right-hand side of the mapping is an expression that is evaluated each time Home is pressed. The expression gives a string, and the result is as if the characters in the string had been pressed. The expression compares col('.') (the cursor column position, where 1 is the first column) and match(getline('.'),'\S')+1 (the index of the first non-whitespace character in the current line; 1 is added because the index starts at 0). If both sides of "==" are equal, the result is '0' (move to start of line); otherwise it is '^' (move to first nonblank character).
noremap <expr> <silent> <Home> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
imap <silent> <Home> <C-O><Home>


""""""" See http://vim.wikia.com/wiki/VimTip431
"Change to forward/back slashesEdit
"The following mappings (for your vimrc) allow easily changing slashes in the current line.
"By default the <Leader> key is backslash, and <Bslash> is a way to refer to a backslash in a mapping, so by default these commands map \/ and \\ respectively.

"Press <Leader>/ to change every backslash to a forward slash, in the current line.

"Press <Leader>\ to change every forward slash to a backslash, in the current line.

"The mappings save and restore the search register (@/) so a previous search can be continued, if wanted. The :noh command is used to remove search highlighting (if enabled) to avoid search hits being highlighted after setting the search register.
"In the substitute command (:s), a colon (:) is used as a delimiter, so the slashes do not need to be escaped. The substitute flags (ge) cause all occurrences on the line to be substituted (g), and no error to be reported if no slash is found (e).

" nnoremap <silent> <Leader>/ :let tmp=@/<Bar>s:\\:/:ge<Bar>let @/=tmp<Bar>noh<CR>
" nnoremap <silent> <Leader><Bslash> :let tmp=@/<Bar>s:/:\\:ge<Bar>let @/=tmp<Bar>noh<CR>
nnoremap <silent> sl :let tmp=@/<Bar>s:\\:/:ge<Bar>let @/=tmp<Bar>noh<CR>
nnoremap <silent> bs :let tmp=@/<Bar>s:/:\\:ge<Bar>let @/=tmp<Bar>noh<CR>



"CG's                                                  : 'Underline current line' mapping
"----------------------------------------------------------------------------------------
"1. copy current line                                  : yyp
"2. remove trailing whitespace in copied line          : :s/\s\+$//e<cr>
"4. Jumop to startof line (ignore preceding whitespace : ^
"5. select until end of line                           : v$
"6. replace with -                                     : r-
"----------------------------------------------------------
nnoremap <leader>ul <esc>yyp:s/\s\+$//e<cr>^v$r-
nnoremap <leader>ul <esc>yyp:s/\s\+$//e<cr>^v$r-
inoremap <leader>ul <esc>yyp:s/\s\+$//e<cr>^v$r-
"----------------------------------------------------------

"Tired of clearing highlighted searches by searching for “ldsfhjkhgakjks”? Use this:
nmap <silent> <leader>/ :nohlsearch<CR>


"search for visual selection
:vmap // y/<C-R>"<CR>


" -----   ruby interpolation via surround plugin -----
"  35 is ASCII code for '#' : determined with :echo char2nr('#')
"  37 is ASCII code for '%' : determined with :echo char2nr('%')
"  61 is ASCII code for '=' : determined with :echo char2nr('=')
let g:surround_35 = "#{\r.inspect}"
let g:surround_37 = "<% \r %>"
let g:surround_61 = "<%= \r %>"

" Expand {xyz} --> { xyz }   ( change open brace )
nnoremap cob :normal cs{{<cr>

nmap <leader>m viwygvS#vf}S'Pli=<esc>4lva'<esc>
vmap <leader>m    ygvS#vf}S'Pli=<esc>4lva'<esc>

" # turns  <cword>  ->  #{<cword>}
vmap <leader># viwS#
nmap <leader># viwS#

" nmap .. :GitGutterNextHunk<cr>
" nmap ,, :GitGutterPrevHunk<cr>
nmap .. ]c
nmap ,, [c


" Removes trailing spaces in current buffer
function! TrimWhiteSpace()
    %s/\s\+$//e
:endfunction


function! CompileGraphvizDotFileAndShow()
  let l:fname = expand('%:p')
  GraphvizCompile
  echo "Viewing " . l:fname
  GraphvizShow
endfunction


""""""""""""""""""""""" NERDTree config """""""""""""""""""""""""""""
let NERDTreeChDirMode=2
"let NERDTreeIgnore=['\env','\.vim$', '\~$', '\.pyc$', '\.swp$', '\.egg-info$', '^dist$', '^build$']
let NERDTreeIgnore=['^\.svn$','\~$', '\.rbc$', '\.swp$', '\.egg-info$', '^dist$', '^build$', '\.a$', '\.o$', '\.so']
let NERDTreeSortOrder=['\.rb$', '\/$', '*']
let NERDTreeShowBookmarks=1
let NERDTreeShowHidden=1
let NERDTreeHightlightCursorline=1
let NERDChristmasTree=1
"open NERDTEE by default"
"autocmd vimenter * NERDTree

"Q. How can I open a NERDTree automatically when vim starts up if no files were specified?
" au! vimenter * if !argc() | NERDTree | endif

"Q. How can I map a specific key or shortcut to open NERDTree?
"A. Stick this in your vimrc to open NERDTree with Ctrl+n (you can set whatever key you want): map <C-n> :NERDTreeToggle<CR>

"Q. How can I close vim if the only window left open is a NERDTree?
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

" autocmd BufWinEnter * NERDTreeFind
map ] :NERDTreeFind<CR> “ pressing this inside any open file in vim will jump to the nerdtree and highlight where that file is -> very useful when you have multiple files open at once


" See http://www.bashoneliners.com/?page=2
" Make a hexdump or do the reverse with the xxd command
" bash$ xxd /path/to/binary/file
" — by openiduser3 on May 16, 2012, 8:22 a.m.
"
" Explanation
" This shows a very nice hexdump of the specified file. You can edit the output and convert it back to binary with xxd -r. But the best part is that you can configure vim to do all the converting back and forth for you, effectively turning vim into a binary editor, by adding this to your .vimrc:
"

augroup Binary
        au!

        au BufReadPre  *.bin let &bin=1
        au BufReadPost *.bin if &bin | %!xxd
        au BufReadPost *.bin set ft=xxd | endif
        au BufWritePre *.bin if &bin | %!xxd -r
        au BufWritePre *.bin endif
        au BufWritePost *.bin if &bin | %!xxd
        au BufWritePost *.bin set nomod | endif

    au BufReadPre  *.hal let &bin=1
    au BufReadPost *.hal if &bin | %!xxd
    au BufReadPost *.hal set ft=xxd | endif
    au BufWritePre *.hal if &bin | %!xxd -r
    au BufWritePre *.hal endif
    au BufWritePost *.hal if &bin | %!xxd
    au BufWritePost *.hal set nomod | endif
augroup END



"   if wanted, you can temporarily turn off Vim's paging so there will be no "More" prompts, as shown in the following example which outputs to register A (so output is appended to register a):
"
"   :redir @A
"   :set nomore
"   :echo 'History'
"   :history
"   :echo 'Scripts loaded'
"   :scriptnames
"   :set nomore
"   :redir END
"   Redirection to a file:
"   :redir > out.txt
"   :registers
"     " any other commands
"   :redir END
"
"   The above writes to the new file out.txt. The command does nothing if that file already exists. To overwrite the file if it exists, use :redir! > out.txt. To create a new file or append to an existing file, use :redir >> out.txt.
"   Store glob results in register a:
"
"   " Clear @a (register a) because need to use A to append.
"   :let @a = ''
"
"   " Append all lines containing 'fred' to register a.
"   :g/fred/y A
"
"   " Append to a file (must use >>).
"   The command uses the :.w command which writes the current line (.) by appending it to file errors.txt.
"   :'a,'b g/^Error/ .w >> errors.txt



"automatically remove trailing whitespace before changing a file
" autocmd FileWritePre    * :call TrimWhiteSpace()
" autocmd FileAppendPre   * :call TrimWhiteSpace()
" autocmd FilterWritePre  * :call TrimWhiteSpace()
" autocmd BufWritePre     * :call TrimWhiteSpace()
" vimwiki
":autocmd bufenter *.wiki set nofen|nmap <F3> <esc>bi[[<ESC>ea]]<ESC>1h|nmap <S-F3> <ESC>eF[F[2xf]2x1h<ESC>
":autocmd bufleave *.wiki nmap <F3> :TagbarToggle<CR>


" See http://stackoverflow.com/questions/890802/vim-disable-press-enter-or-type-command-to-continue-prompt"
"  This is how I dealt with the problem that running an external program through silent messes up the screen in text-mode vim (in my experience, gvim doesn't suffer from this problem):
"
command! -nargs=1 Silent
 \ | execute ':silent !'.<q-args>
 \ | execute ':redraw!'


" Enable spell checking -----
" set spell
"
" Disable spell checking
set nospell
"
" See https://www.andiamo.co.uk/resources/iso-language-codes for the list of available ISO 639-1 language codes
"
"   - using the ENGLISH,GERMAN and FRENCH dictionaries
set spelllang=en,de,fr
"
"   - using the AMERICAN ENGLISH dictionary
" set spelllang=en-us
"
"   - using the FRENCH dictionary
" set spelllang=fr
"
"   - using the GERMAN dictionary
" set spelllang=de
"
" ------   Enable spell checking -----



" Append modeline after last line in buffer.
" Use substitute() instead of printf() to handle '%%s' modeline in LaTeX
" files.
function! AppendModeline()
  let l:modeline = printf(" vim: set ts=%d sw=%d tw=%d %set :",
        \ &tabstop, &shiftwidth, &textwidth, &expandtab ? '' : 'no')
  let l:modeline = substitute(&commentstring, "%s", l:modeline, "")
  call append(line("$"), l:modeline)
endfunction
nnoremap <silent> <Leader>ml :call AppendModeline()<CR>


function! ToggleColorColumn()
    if &colorcolumn
        set colorcolumn=
    else
        set colorcolumn=120
    endif
endfunction



" Plug undo
nnoremap <S-F2> :call LanguageClient_contextMenu()<CR>
nnoremap <F3> :set wrap! linebreak!<CR> <BAR>:echom 'Toggled line wrapping!' <CR> " toggle line wrapping
nnoremap <F4> :NERDTreeToggle<CR>                                     " Toogle NERDTree
nnoremap <F5> :UndotreeToggle<cr>        " nnoremap <F6> :call ToggleSyntax()<CR>
nnoremap <F6> :call ToggleColorColumn()<CR>
inoremap <F7> <C-R>=expand('%:p:h')<CR>
cnoremap <F7> <C-R>=expand('%:p:h')<CR>
nmap <F8> <Plug>(ale_fix)   " Bind F8 to fixing problems with ALE
nnoremap <F9> :let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar><CR> <BAR>:echom 'Erased trailing whitespace !' <CR> " Remove all trailing whitespace (https://vim.fandom.com/wiki/Remove_unwanted_spaces) explicitly by pressing F5


if g:has_goyo
    " Plug undo
    " Plug goyo
    map <ENTER><ENTER> :GoyoToggle<CR>
endif



" You can insert the result of a Vim expression in insert mode using the <C-R>= command.
" See: https://vim.fandom.com/wiki/Mapping_keys_in_Vim_-_Tutorial_(Part_1)
" For example, the following command creates an insert mode map command that inserts the current directory:
"
" :inoremap <F2> <C-R>=expand('%:p:h')<CR>
"
" If you don't want to insert anything then you can return an empty string from the expression.
" For example, you can invoke a function from the insert mode map to perform some operation but return an empty string from the function.
"
" The <C-R>= command doesn't create a new undo point. You can also call Vim functions using the <C-R>= command:
"
" :inoremap <F2> <C-R>=MyVimFunc()<CR>
"
" If the return value of MyVimFunc() is to be ignored and not entered after its call, a ternary operator trick may be used:
"
" :inoremap <F2> <C-R>=MyVimFunc()?'':''<CR>
"
" This will return an empty string, independent of what MyVimFunc() returns.


" set mouse=a " Enables mouse support for all important modes
" set mouse=vic    " Disables mouse support for all modes except visual,insert,command modi (eg. disables mouse for normal mode)
" set mouse+=a   "Enabled mouse for all importnt modi

if exists('+ttymouse') "if !has('nvim')
    set ttymouse=sgr " To get mouse working using the Alacritty terminal emulator
endif

if exists('+guioptions')  " Only for gui vim like gvim, ...
    set guioptions-=m     " remove menubar
    set guioptions-=T     " remove toolbar
    set guioptions-=r     " remove right-hand scrollbar
    set guioptions-=L     " remove left-hand scrollbar
endif



" C-s to save file
noremap <silent> <C-S>          :update<CR>
vnoremap <silent> <C-S>         <C-C>:update<CR>
inoremap <silent> <C-S>         <C-O>:update<CR>


" ####### Copy and Paste #######

" Copy only to clipboard register (@+)
" vnoremap <C-c>      "+y

" Copy first to primary selection register (@*), the copy from primary selection register to clipboard register (@+)
vnoremap <C-c>      "*y :let @+=@*<CR>

" Paste content of clipboard register (@+)
noremap      <C-v>      "+p

" By default zoom-toggle is mapped to: <C-W>m (MAXIMIZE)
" To be consistent with tmux we map it to <C-W>z (ZOOM) instead
nmap <silent> <C-W>z <Plug>(zoom-toggle)
nmap <silent> <C-z> <Plug>(zoom-toggle)
" nmap <silent> <A-z> <Plug>(zoom-toggle)


" Remap FZF (fuzzy finder) invocation key to Ctrl-f
" nnoremap <silent> <C-f> :FZF<CR>
nnoremap <silent> <leader>f :FZF<CR>

"set statusline+=%{zoom#statusline()}

" setup nvim as default pager (for man pages)
let $PAGER=''


" Some tricks from https://github.com/bbkane/dotfiles/blob/91ac752ac4a25eca1f3ff271249d2e5878b265b2/nvim/.config/nvim/init.vim#L397



"----------------- CG -------------------
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" sdf sdfdsdf

" Plug Rainbow config {
au FileType c,cpp,objc,objcpp call rainbow#load()
" or just this to enable it globally:
" let g:rainbow_active = 1
" Plug Rainbow config }



" vim-airline plugin config.
" let g:airline_theme='gruvbox'
let g:airline_theme='dark'
let g:airline_powerline_fonts=1 " required if using https://github.com/bling/vim-airline
" vim-airline plugin config.

" vim-bookmarks plugin config.
highlight BookmarkSign ctermbg=NONE ctermfg=160
" highlight BookmarkLine ctermbg=lightgrey ctermfg=black
" highlight BookmarkLine ctermbg=NONE ctermfg=NONE
"
let g:bookmark_sign = '♥'
let g:bookmark_highlight_lines = 1
"
" nnoremap  :BookmarkToggle<CR>
nnoremap <C-d> :BookmarkToggle<CR>
nnoremap <leader>bm :BookmarkToggle<CR>
" vim-bookmarks plugin config.


" vim-tcomment plugin config.
nnoremap <leader>cc :TComment<CR>
vnoremap <leader>cc :TComment<CR>
nnoremap // :TComment<CR>
" vim-tcomment plugin config.


" source $HOME/dotfiles/vim_files/plugin_cfg/LanguageClient-neovim.vim
" source $HOME/dotfiles/vim_files/plugin_cfg/deoplete.vim

" Deoplete (completion engine) expects you to use the arrow keys to select
" from suggestion dropdowns while coding
" which isn’t ideal for most Vim users and hence it is recommended
" to map the ctrl-j and ctrl-k bindings to the up and down arrow keys.
" This can be achieved by adding the following lines to your ‘init.vim’
" configuration file (pumvisibible: 'PopUpMenu Visible'):
inoremap <expr> <C-j> pumvisible() ? "\<C-n>" : "\<C-j>"
inoremap <expr> <C-k> pumvisible() ? "\<C-p>" : "\<C-k>"


" To easily activate the plugin you can map it the “<leader>s” key binding by adding the following line to your ‘init.vim’ file.
" Default easymotion-prefix is: <leader><leader>w
" map <leader>s <Plug>(easymotion-prefix)

"Remove all trailing whitespace (https://vim.fandom.com/wiki/Remove_unwanted_spaces)
" implicitly upon buffer write
" The following only changes files with the extension .pl:
" autocmd BufWritePre *.pl %s/\s\+$//e
autocmd BufWritePre * %s/\s\+$//e
" Additionally, a FileType autocommand can be used to restrict the autocmd to certain file types only.
" autocmd FileType c,cpp,java,php autocmd BufWritePre <buffer> %s/\s\+$//e


source $HOME/dotfiles/vim_files/scripts/grep_cfg.vim

"#############################################################################

" ----------------------------- Plugin configurations -----------------------------{"
source $HOME/dotfiles/vim_files/plugin_cfg/LanguageClient-neovim.vim
source $HOME/dotfiles/vim_files/plugin_cfg/deoplete.vim
source $HOME/dotfiles/vim_files/plugin_cfg/startify.vim
source $HOME/dotfiles/vim_files/plugin_cfg/auto-pairs.vim
source $HOME/dotfiles/vim_files/plugin_cfg/ale.vim
source $HOME/dotfiles/vim_files/plugin_cfg/sneak.vim
source $HOME/dotfiles/vim_files/plugin_cfg/vim-highlightedyank.vim
source $HOME/dotfiles/vim_files/plugin_cfg/scalpel.vim
source $HOME/dotfiles/vim_files/plugin_cfg/codi.vim
source $HOME/dotfiles/vim_files/plugin_cfg/vifm.vim
source $HOME/dotfiles/vim_files/plugin_cfg/arpeggio.vim
source $HOME/dotfiles/vim_files/plugin_cfg/ranger.vim
source $HOME/dotfiles/vim_files/plugin_cfg/vim-be-good.vim
source $HOME/dotfiles/vim_files/plugin_cfg/vim-which-key.vim
source $HOME/dotfiles/vim_files/plugin_cfg/coc.vim
source $HOME/dotfiles/vim_files/plugin_cfg/vim-tmux-navigator.vim
source $HOME/dotfiles/vim_files/plugin_cfg/vim-rooter_rendon.vim
" ----------------------------- Plugin configurations -----------------------------}"

source $HOME/dotfiles/vim_files/scripts/setup_diff_settings.vim


" LAST LINE
" vim: set ts=4 sw=4 tw=78 et :
